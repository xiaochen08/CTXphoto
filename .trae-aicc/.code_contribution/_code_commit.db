{
  "range-cache-file:///c%3A/Users/123/%E4%BB%A3%E7%A0%81/photo_sorter_modern.py": "[{\"originRange\":{\"start\":{\"line\":0,\"character\":0},\"end\":{\"line\":1456,\"character\":13}},\"modifyRange\":{\"start\":{\"line\":0,\"character\":0},\"end\":{\"line\":1456,\"character\":13}},\"action\":\"None\",\"isLine\":false,\"originText\":\"# 陈同学影像管理助手 v2.0.0\\\\n# 现代UI版本 - 保留所有核心功能，增强视觉体验和交互性\\\\n\\\\nimport os, sys, json, time, shutil, platform, subprocess, re\\\\nimport tkinter as tk\\\\nfrom tkinter import ttk, messagebox, filedialog, simpledialog\\\\nfrom datetime import datetime\\\\nimport threading\\\\nfrom PIL import Image, ImageTk, ExifTags\\\\nimport psutil\\\\nimport exifread\\\\nfrom typing import Dict, List, Tuple, Optional, Set\\\\n\\\\nVERSION = \\\\\\\"v2.0.0\\\\\\\"\\\\nCONFIG_FILE = \\\\\\\"photo_sorter_config.json\\\\\\\"\\\\nCATEGORIES = [\\\\\\\"婚礼\\\\\\\", \\\\\\\"写真\\\\\\\", \\\\\\\"日常记录\\\\\\\", \\\\\\\"旅游记录\\\\\\\", \\\\\\\"商业活动拍摄\\\\\\\"]\\\\nTHEMES = [\\\\\\\"日间\\\\\\\", \\\\\\\"暗黑\\\\\\\"]\\\\n\\\\n# 支持的文件类型\\\\ndef is_raw_ext(e): return e.lower() in {\\\\\\\"cr2\\\\\\\", \\\\\\\"cr3\\\\\\\", \\\\\\\"nef\\\\\\\", \\\\\\\"nrw\\\\\\\", \\\\\\\"arw\\\\\\\", \\\\\\\"srf\\\\\\\", \\\\\\\"sr2\\\\\\\", \\\\\\\"raf\\\\\\\", \\\\\\\"rw2\\\\\\\", \\\\\\\"orf\\\\\\\", \\\\\\\"dng\\\\\\\", \\\\\\\"pef\\\\\\\", \\\\\\\"raw\\\\\\\"}\\\\ndef is_jpg_ext(e): return e.lower() in {\\\\\\\"jpg\\\\\\\", \\\\\\\"jpeg\\\\\\\", \\\\\\\"jpe\\\\\\\"}\\\\ndef is_video_ext(e): return e.lower() in {\\\\\\\"mp4\\\\\\\", \\\\\\\"mov\\\\\\\", \\\\\\\"avi\\\\\\\", \\\\\\\"mkv\\\\\\\", \\\\\\\"wmv\\\\\\\"}\\\\ndef is_image_ext(e): return is_raw_ext(e) or is_jpg_ext(e)\\\\n\\\\n# 提示音功能\\\\ntry:\\\\n    import winsound\\\\n    def beep_start(): winsound.MessageBeep(winsound.MB_ICONASTERISK)\\\\n    def beep_done():  winsound.MessageBeep(winsound.MB_ICONEXCLAMATION)\\\\nexcept Exception:\\\\n    def beep_start(): pass\\\\n    def beep_done():  pass\\\\n\\\\n# ---------- 工具函数 ----------\\\\ndef ts(): return datetime.now().strftime(\\\\\\\"%H:%M:%S\\\\\\\")\\\\n\\\\ndef bytes_to_human(n) -> str:\\\\n    try: n = int(n)\\\\n    except Exception: return \\\\\\\"N/A\\\\\\\"\\\\n    units = [\\\\\\\"B\\\\\\\", \\\\\\\"KB\\\\\\\", \\\\\\\"MB\\\\\\\", \\\\\\\"GB\\\\\\\", \\\\\\\"TB\\\\\\\", \\\\\\\"PB\\\\\\\", \\\\\\\"EB\\\\\\\"]\\\\n    i = 0; v = float(n)\\\\n    while v >= 1024.0 and i < len(units) - 1:\\\\n        v /= 1024.0; i += 1\\\\n    return f\\\\\\\"{v:.2f} {units[i]}\\\\\\\"\\\\n\\\\ndef get_drive_type_code(letter):\\\\n    import ctypes\\\\n    try: return ctypes.windll.kernel32.GetDriveTypeW(letter + \\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\")\\\\n    except Exception: return 0\\\\n\\\\ndef drive_type_name(code): return {2:\\\\\\\"移动\\\\\\\",3:\\\\\\\"固定\\\\\\\",4:\\\\\\\"网络\\\\\\\",5:\\\\\\\"光驱\\\\\\\",6:\\\\\\\"RAM\\\\\\\"}.get(code,\\\\\\\"未知\\\\\\\")\\\\ndef is_system_drive(letter): return letter.upper().startswith(os.environ.get(\\\\\\\"SystemDrive\\\\\\\",\\\\\\\"C:\\\\\\\").upper())\\\\ndef list_drives(): return [p.device for p in psutil.disk_partitions(all=True) if os.path.exists(p.mountpoint)]\\\\n\\\\ndef get_drive_label(letter):\\\\n    import ctypes\\\\n    try:\\\\n        vn=ctypes.create_unicode_buffer(1024); fs=ctypes.create_unicode_buffer(1024)\\\\n        sn=ctypes.c_ulong(); mcl=ctypes.c_ulong(); fl=ctypes.c_ulong()\\\\n        ctypes.windll.kernel32.GetVolumeInformationW(letter+\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\",vn,1024,ctypes.byref(sn),ctypes.byref(mcl),ctypes.byref(fl),fs,1024)\\\\n        name=vn.value.strip()\\\\n    except Exception: name=\\\\\\\"\\\\\\\"\\\\n    if not name and get_drive_type_code(letter)==2: return \\\\\\\"U盘\\\\\\\"\\\\n    return name or \\\\\\\"(无名称)\\\\\\\"\\\\n\\\\ndef get_drive_usage_bytes(root):\\\\n    u=psutil.disk_usage(root); return u.total,u.free\\\\n\\\\ndef load_config():\\\\n    if os.path.exists(CONFIG_FILE):\\\\n        with open(CONFIG_FILE,\\\\\\\"r\\\\\\\",encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            cfg = json.load(f)\\\\n            # 确保配置项存在\\\\n            if \\\\\\\"theme\\\\\\\" not in cfg: cfg[\\\\\\\"theme\\\\\\\"] = \\\\\\\"light\\\\\\\"\\\\n            if \\\\\\\"sash_ratio\\\\\\\" not in cfg: cfg[\\\\\\\"sash_ratio\\\\\\\"] = 0.55\\\\n            if \\\\\\\"window_pos\\\\\\\" not in cfg: cfg[\\\\\\\"window_pos\\\\\\\"] = {\\\\\\\"x\\\\\\\": 100, \\\\\\\"y\\\\\\\": 100}\\\\n            if \\\\\\\"window_size\\\\\\\" not in cfg: cfg[\\\\\\\"window_size\\\\\\\"] = {\\\\\\\"width\\\\\\\": 1000, \\\\\\\"height\\\\\\\": 720}\\\\n            return cfg\\\\n    return {\\\\\\\"last_target_root\\\\\\\": \\\\\\\"\\\\\\\", \\\\\\\"theme\\\\\\\": \\\\\\\"light\\\\\\\", \\\\\\\"sash_ratio\\\\\\\": 0.55, \\\\\\\"window_pos\\\\\\\": {\\\\\\\"x\\\\\\\": 100, \\\\\\\"y\\\\\\\": 100}, \\\\\\\"window_size\\\\\\\": {\\\\\\\"width\\\\\\\": 1000, \\\\\\\"height\\\\\\\": 720}}\\\\n\\\\ndef save_config(cfg):\\\\n    with open(CONFIG_FILE,\\\\\\\"w\\\\\\\",encoding=\\\\\\\"utf-8\\\\\\\") as f: json.dump(cfg,f,ensure_ascii=False,indent=2)\\\\n\\\\n# ---------- EXIF / XMP处理 ----------\\\\ndef _parse_exif_str(s):\\\\n    s=s.strip()\\\\n    if len(s)>=19 and s[4]==\\\\\\\":\\\\\\\" and s[7]==\\\\\\\":\\\\\\\" and s[10]==\\\\\\\" \\\\\\\" and s[13]==\\\\\\\":\\\\\\\" and s[16]==\\\\\\\":\\\\\\\" :\\\\n        return datetime.strptime(s[:19],\\\\\\\"%Y:%m:%d %H:%M:%S\\\\\\\")\\\\n    return None\\\\n\\\\ndef _exif_dt_from_jpg(p):\\\\n    try:\\\\n        im=Image.open(p); exif=im._getexif()\\\\n        if not exif: return None\\\\n        tag={ExifTags.TAGS.get(k,k):v for k,v in exif.items()}\\\\n        for k in(\\\\\\\"DateTimeOriginal\\\\\\\",\\\\\\\"DateTimeDigitized\\\\\\\",\\\\\\\"DateTime\\\\\\\"):\\\\n            v=tag.get(k)\\\\n            if isinstance(v,str):\\\\n                dt=_parse_exif_str(v)\\\\n                if dt: return dt\\\\n    except Exception: pass\\\\n    return None\\\\n\\\\ndef _exif_dt_from_any(p):\\\\n    try:\\\\n        with open(p,\\\\\\\"rb\\\\\\\") as f: tags=exifread.process_file(f,stop_tag=\\\\\\\"EXIF DateTimeOriginal\\\\\\\",details=False)\\\\n        for k in(\\\\\\\"EXIF DateTimeOriginal\\\\\\\",\\\\\\\"Image DateTime\\\\\\\",\\\\\\\"EXIF DateTimeDigitized\\\\\\\"):\\\\n            if k in tags:\\\\n                dt=_parse_exif_str(str(tags[k]))\\\\n                if dt: return dt\\\\n    except Exception: pass\\\\n    return None\\\\n\\\\ndef get_capture_dt(p):\\\\n    ext=p.rsplit(\\\\\\\".\\\\\\\",1)[-1].lower() if \\\\\\\".\\\\\\\" in p else \\\\\\\"\\\\\\\"\\\\n    if is_jpg_ext(ext): dt=_exif_dt_from_jpg(p) or _exif_dt_from_any(p)\\\\n    elif is_raw_ext(ext): dt=_exif_dt_from_any(p)\\\\n    else: dt=None\\\\n    if dt: return dt\\\\n    try: return datetime.fromtimestamp(os.path.getmtime(p))\\\\n    except Exception: return datetime.now()\\\\n\\\\n# ---------- 星标检测 ----------\\\\n_XMP_RATING_PATTERNS = [\\\\n    re.compile(rb\\\\\\\"<xmp:Rating>\\\\\\\\s*(-?\\\\\\\\d+)\\\\\\\\s*</xmp:Rating>\\\\\\\", re.I),\\\\n    re.compile(rb\\\\\\\"Rating=\\\\\\\\\\\\\\\"\\\\\\\\s*(-?\\\\\\\\d+)\\\\\\\\s*\\\\\\\\\\\\\\\"\\\\\\\", re.I),\\\\n]\\\\n\\\\ndef _find_rating_in_bytes(b: bytes) -> int:\\\\n    for pat in _XMP_RATING_PATTERNS:\\\\n        m = pat.search(b)\\\\n        if m:\\\\n            try: return int(m.group(1))\\\\n            except Exception: pass\\\\n    return 0\\\\n\\\\ndef is_starred_file(path: str) -> bool:\\\\n    stem, _ = os.path.splitext(path)\\\\n    sidecar = stem + \\\\\\\".xmp\\\\\\\"\\\\n    try:\\\\n        if os.path.isfile(sidecar):\\\\n            with open(sidecar, \\\\\\\"rb\\\\\\\") as f:\\\\n                rating = _find_rating_in_bytes(f.read(512*1024))\\\\n                return rating >= 1\\\\n    except Exception:\\\\n        pass\\\\n    try:\\\\n        with open(path, \\\\\\\"rb\\\\\\\") as f:\\\\n            rating = _find_rating_in_bytes(f.read(1024*1024))\\\\n            return rating >= 1\\\\n    except Exception:\\\\n        return False\\\\n\\\\n# ---------- 其他工具 ----------\\\\ndef unique_path(d, f):\\\\n    n, e = os.path.splitext(f); c = os.path.join(d, f); i = 1\\\\n    while os.path.exists(c):\\\\n        c = os.path.join(d, f\\\\\\\"{n}({i}){e}\\\\\\\"); i += 1\\\\n    return c\\\\n\\\\ndef _open_folder(p):\\\\n    try:\\\\n        if platform.system() == \\\\\\\"Windows\\\\\\\": os.startfile(p)\\\\n        elif platform.system() == \\\\\\\"Darwin\\\\\\\": subprocess.Popen([\\\\\\\"open\\\\\\\", p])\\\\n        else: subprocess.Popen([\\\\\\\"xdg-open\\\\\\\", p])\\\\n    except Exception:\\\\n        pass\\\\n\\\\n# ---------- 日志处理 ----------\\\\ndef log_init_if_empty(text_widget, line):\\\\n    if float(text_widget.index(\\\\\\\"end-1c\\\\\\\")) == 1.0:\\\\n        text_widget.configure(state=\\\\\\\"normal\\\\\\\")\\\\n        text_widget.insert(\\\\\\\"end\\\\\\\", f\\\\\\\"[{ts()}] {line}\\\\\\\\n\\\\\\\")\\\\n        text_widget.configure(state=\\\\\\\"disabled\\\\\\\")\\\\n\\\\ndef log_add(text_widget, line):\\\\n    text_widget.configure(state=\\\\\\\"normal\\\\\\\")\\\\n    text_widget.insert(\\\\\\\"end\\\\\\\", f\\\\\\\"[{ts()}] {line}\\\\\\\\n\\\\\\\")\\\\n    text_widget.see(\\\\\\\"end\\\\\\\")\\\\n    text_widget.configure(state=\\\\\\\"disabled\\\\\\\")\\\\n\\\\n# ---------- 扫描/计划 ----------\\\\ndef preflight_scan(src_root):\\\\n    counts = {\\\\\\\"RAW\\\\\\\": 0, \\\\\\\"JPG\\\\\\\": 0, \\\\\\\"VIDEO\\\\\\\": 0};\\\\n    sizes = {\\\\\\\"RAW\\\\\\\": 0, \\\\\\\"JPG\\\\\\\": 0, \\\\\\\"VIDEO\\\\\\\": 0}\\\\n    files = {\\\\\\\"RAW\\\\\\\": [], \\\\\\\"JPG\\\\\\\": [], \\\\\\\"VIDEO\\\\\\\": []}\\\\n    \\\\n    for root, _, fs in os.walk(src_root):\\\\n        for f in fs:\\\\n            ext = f.rsplit(\\\\'.\\\\', 1)[-1].lower() if \\\\'.\\\\' in f else \\\\\\\"\\\\\\\"\\\\n            full = os.path.join(root, f)\\\\n            try: sz = os.path.getsize(full)\\\\n            except Exception: sz = 0\\\\n            \\\\n            if is_raw_ext(ext): \\\\n                counts[\\\\\\\"RAW\\\\\\\"] += 1; sizes[\\\\\\\"RAW\\\\\\\"] += sz; files[\\\\\\\"RAW\\\\\\\"].append(full)\\\\n            elif is_jpg_ext(ext): \\\\n                counts[\\\\\\\"JPG\\\\\\\"] += 1; sizes[\\\\\\\"JPG\\\\\\\"] += sz; files[\\\\\\\"JPG\\\\\\\"].append(full)\\\\n            elif is_video_ext(ext): \\\\n                counts[\\\\\\\"VIDEO\\\\\\\"] += 1; sizes[\\\\\\\"VIDEO\\\\\\\"] += sz; files[\\\\\\\"VIDEO\\\\\\\"].append(full)\\\\n    \\\\n    return counts, sizes, files\\\\n\\\\ndef build_seq_plan(photo_files, mmdd_str):\\\\n    entries = []\\\\n    for p in photo_files:\\\\n        ext = p.rsplit(\\\\\\\".\\\\\\\", 1)[-1].lower() if \\\\\\\".\\\\\\\" in p else \\\\\\\"\\\\\\\"\\\\n        stem = os.path.splitext(os.path.basename(p))[0]\\\\n        dt = get_capture_dt(p)\\\\n        entries.append({\\\\\\\"path\\\\\\\": p, \\\\\\\"ext\\\\\\\": ext, \\\\\\\"stem\\\\\\\": stem, \\\\\\\"dt\\\\\\\": dt})\\\\n    \\\\n    entries.sort(key=lambda x: (x[\\\\\\\"dt\\\\\\\"], x[\\\\\\\"stem\\\\\\\"], x[\\\\\\\"ext\\\\\\\"]))\\\\n    stem_to_idx = {}; seq = 0; plan = []\\\\n    \\\\n    for e in entries:\\\\n        if e[\\\\\\\"stem\\\\\\\"] in stem_to_idx: idx = stem_to_idx[e[\\\\\\\"stem\\\\\\\"]]\\\\n        else: seq += 1; idx = seq; stem_to_idx[e[\\\\\\\"stem\\\\\\\"]] = idx\\\\n        plan.append((e[\\\\\\\"path\\\\\\\"], f\\\\\\\"{mmdd_str}-{idx:04d}\\\\\\\", e[\\\\\\\"ext\\\\\\\"]))\\\\n    \\\\n    return plan\\\\n\\\\n# ---------- 主题管理 ----------\\\\nclass ThemeManager:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"主题管理器 - 提供现代UI的主题支持\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    \\\\n    THEMES = {\\\\n        \\\\\\\"light\\\\\\\": {\\\\n            \\\\\\\"BG\\\\\\\": \\\\\\\"#F8FAFC\\\\\\\",\\\\n            \\\\\\\"CARD\\\\\\\": \\\\\\\"#FFFFFF\\\\\\\",\\\\n            \\\\\\\"TEXT\\\\\\\": \\\\\\\"#1E293B\\\\\\\",\\\\n            \\\\\\\"TEXT_SECONDARY\\\\\\\": \\\\\\\"#64748B\\\\\\\",\\\\n            \\\\\\\"BORDER\\\\\\\": \\\\\\\"#E2E8F0\\\\\\\",\\\\n            \\\\\\\"PRIMARY\\\\\\\": \\\\\\\"#3B82F6\\\\\\\",  # 蓝色主题\\\\n            \\\\\\\"PRIMARY_HOVER\\\\\\\": \\\\\\\"#2563EB\\\\\\\",\\\\n            \\\\\\\"SUCCESS\\\\\\\": \\\\\\\"#10B981\\\\\\\",  # 绿色\\\\n            \\\\\\\"WARNING\\\\\\\": \\\\\\\"#F59E0B\\\\\\\",  # 黄色\\\\n            \\\\\\\"DANGER\\\\\\\": \\\\\\\"#EF4444\\\\\\\",   # 红色\\\\n            \\\\\\\"INPUT_BG\\\\\\\": \\\\\\\"#FFFFFF\\\\\\\",\\\\n            \\\\\\\"INPUT_FG\\\\\\\": \\\\\\\"#1E293B\\\\\\\",\\\\n            \\\\\\\"PROGRESS_BG\\\\\\\": \\\\\\\"#E2E8F0\\\\\\\",\\\\n            \\\\\\\"LOG_BG\\\\\\\": \\\\\\\"#F1F5F9\\\\\\\",\\\\n            \\\\\\\"SHADOW\\\\\\\": \\\\\\\"0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)\\\\\\\"\\\\n        },\\\\n        \\\\\\\"dark\\\\\\\": {\\\\n            \\\\\\\"BG\\\\\\\": \\\\\\\"#0F172A\\\\\\\",\\\\n            \\\\\\\"CARD\\\\\\\": \\\\\\\"#1E293B\\\\\\\",\\\\n            \\\\\\\"TEXT\\\\\\\": \\\\\\\"#F8FAFC\\\\\\\",\\\\n            \\\\\\\"TEXT_SECONDARY\\\\\\\": \\\\\\\"#94A3B8\\\\\\\",\\\\n            \\\\\\\"BORDER\\\\\\\": \\\\\\\"#334155\\\\\\\",\\\\n            \\\\\\\"PRIMARY\\\\\\\": \\\\\\\"#3B82F6\\\\\\\",\\\\n            \\\\\\\"PRIMARY_HOVER\\\\\\\": \\\\\\\"#60A5FA\\\\\\\",\\\\n            \\\\\\\"SUCCESS\\\\\\\": \\\\\\\"#10B981\\\\\\\",\\\\n            \\\\\\\"WARNING\\\\\\\": \\\\\\\"#F59E0B\\\\\\\",\\\\n            \\\\\\\"DANGER\\\\\\\": \\\\\\\"#EF4444\\\\\\\",\\\\n            \\\\\\\"INPUT_BG\\\\\\\": \\\\\\\"#334155\\\\\\\",\\\\n            \\\\\\\"INPUT_FG\\\\\\\": \\\\\\\"#F8FAFC\\\\\\\",\\\\n            \\\\\\\"PROGRESS_BG\\\\\\\": \\\\\\\"#334155\\\\\\\",\\\\n            \\\\\\\"LOG_BG\\\\\\\": \\\\\\\"#0F172A\\\\\\\",\\\\n            \\\\\\\"SHADOW\\\\\\\": \\\\\\\"0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2)\\\\\\\"\\\\n        }\\\\n    }\\\\n    \\\\n    @staticmethod\\\\n    def apply_theme(root, theme_key, widgets=None):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"应用主题到根窗口和指定控件\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        style = ttk.Style()\\\\n        try: style.theme_use(\\\\\\\"clam\\\\\\\")\\\\n        except Exception: pass\\\\n        \\\\n        P = ThemeManager.THEMES[\\\\\\\"dark\\\\\\\" if theme_key == \\\\\\\"dark\\\\\\\" else \\\\\\\"light\\\\\\\"]\\\\n        \\\\n        # 配置根窗口\\\\n        root.configure(bg=P[\\\\\\\"BG\\\\\\\"])\\\\n        \\\\n        # 配置ttk样式\\\\n        # 标题标签\\\\n        style.configure(\\\\n            \\\\\\\"Modern.Title.TLabel\\\\\\\",\\\\n            background=P[\\\\\\\"BG\\\\\\\"],\\\\n            foreground=P[\\\\\\\"TEXT\\\\\\\"],\\\\n            font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 20, \\\\\\\"bold\\\\\\\"),\\\\n            padding=(0, 10)\\\\n        )\\\\n        \\\\n        # 副标题标签\\\\n        style.configure(\\\\n            \\\\\\\"Modern.Subtitle.TLabel\\\\\\\",\\\\n            background=P[\\\\\\\"BG\\\\\\\"],\\\\n            foreground=P[\\\\\\\"TEXT\\\\\\\"],\\\\n            font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 14, \\\\\\\"bold\\\\\\\"),\\\\n            padding=(0, 8)\\\\n        )\\\\n        \\\\n        # 正文标签\\\\n        style.configure(\\\\n            \\\\\\\"Modern.Body.TLabel\\\\\\\",\\\\n            background=P[\\\\\\\"BG\\\\\\\"],\\\\n            foreground=P[\\\\\\\"TEXT\\\\\\\"],\\\\n            font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 12),\\\\n            padding=(0, 4)\\\\n        )\\\\n        \\\\n        # 次要文本标签\\\\n        style.configure(\\\\n            \\\\\\\"Modern.Secondary.TLabel\\\\\\\",\\\\n            background=P[\\\\\\\"BG\\\\\\\"],\\\\n            foreground=P[\\\\\\\"TEXT_SECONDARY\\\\\\\"],\\\\n            font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 11),\\\\n            padding=(0, 4)\\\\n        )\\\\n        \\\\n        # 框架样式\\\\n        style.configure(\\\\n            \\\\\\\"Modern.Frame.TFrame\\\\\\\",\\\\n            background=P[\\\\\\\"BG\\\\\\\"],\\\\n            borderwidth=0\\\\n        )\\\\n        \\\\n        # 卡片样式\\\\n        style.configure(\\\\n            \\\\\\\"Modern.Card.TFrame\\\\\\\",\\\\n            background=P[\\\\\\\"CARD\\\\\\\"],\\\\n            borderwidth=1,\\\\n            relief=\\\\\\\"flat\\\\\\\",\\\\n            bordercolor=P[\\\\\\\"BORDER\\\\\\\"]\\\\n        )\\\\n        \\\\n        # 主按钮\\\\n        style.configure(\\\\n            \\\\\\\"Modern.Primary.TButton\\\\\\\",\\\\n            background=P[\\\\\\\"PRIMARY\\\\\\\"],\\\\n            foreground=\\\\\\\"#FFFFFF\\\\\\\",\\\\n            font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 12, \\\\\\\"bold\\\\\\\"),\\\\n            padding=(12, 6),\\\\n            borderwidth=0,\\\\n            focuscolor=\\\\\\\"none\\\\\\\"\\\\n        )\\\\n        style.map(\\\\n            \\\\\\\"Modern.Primary.TButton\\\\\\\",\\\\n            background=[(\\\\\\\"active\\\\\\\", P[\\\\\\\"PRIMARY_HOVER\\\\\\\"])],\\\\n            relief=[(\\\\\\\"pressed\\\\\\\", \\\\\\\"flat\\\\\\\")]\\\\n        )\\\\n        \\\\n        # 次要按钮\\\\n        style.configure(\\\\n            \\\\\\\"Modern.Secondary.TButton\\\\\\\",\\\\n            background=P[\\\\\\\"BORDER\\\\\\\"],\\\\n            foreground=P[\\\\\\\"TEXT\\\\\\\"],\\\\n            font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 12),\\\\n            padding=(12, 6),\\\\n            borderwidth=0\\\\n        )\\\\n        style.map(\\\\n            \\\\\\\"Modern.Secondary.TButton\\\\\\\",\\\\n            background=[(\\\\\\\"active\\\\\\\", P[\\\\\\\"CARD\\\\\\\"])],\\\\n            relief=[(\\\\\\\"pressed\\\\\\\", \\\\\\\"flat\\\\\\\")]\\\\n        )\\\\n        \\\\n        # 进度条\\\\n        style.configure(\\\\n            \\\\\\\"Modern.Horizontal.TProgressbar\\\\\\\",\\\\n            troughcolor=P[\\\\\\\"PROGRESS_BG\\\\\\\"],\\\\n            background=P[\\\\\\\"PRIMARY\\\\\\\"],\\\\n            bordercolor=P[\\\\\\\"PROGRESS_BG\\\\\\\"],\\\\n            lightcolor=P[\\\\\\\"PRIMARY\\\\\\\"],\\\\n            darkcolor=P[\\\\\\\"PRIMARY\\\\\\\"],\\\\n            borderwidth=0\\\\n        )\\\\n        \\\\n        # 下拉框\\\\n        style.configure(\\\\n            \\\\\\\"Modern.TCombobox\\\\\\\",\\\\n            fieldbackground=P[\\\\\\\"INPUT_BG\\\\\\\"],\\\\n            background=P[\\\\\\\"INPUT_BG\\\\\\\"],\\\\n            foreground=P[\\\\\\\"INPUT_FG\\\\\\\"],\\\\n            bordercolor=P[\\\\\\\"BORDER\\\\\\\"],\\\\n            arrowcolor=P[\\\\\\\"TEXT\\\\\\\"],\\\\n            font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 11),\\\\n            padding=(6, 4)\\\\n        )\\\\n        style.map(\\\\n            \\\\\\\"Modern.TCombobox\\\\\\\",\\\\n            fieldbackground=[(\\\\\\\"readonly\\\\\\\", P[\\\\\\\"INPUT_BG\\\\\\\"])],\\\\n            foreground=[(\\\\\\\"readonly\\\\\\\", P[\\\\\\\"INPUT_FG\\\\\\\"])],\\\\n            background=[(\\\\\\\"readonly\\\\\\\", P[\\\\\\\"INPUT_BG\\\\\\\"])],\\\\n            arrowcolor=[(\\\\\\\"active\\\\\\\", P[\\\\\\\"PRIMARY\\\\\\\"])]\\\\n        )\\\\n        \\\\n        # 复选框\\\\n        style.configure(\\\\n            \\\\\\\"Modern.TCheckbutton\\\\\\\",\\\\n            background=P[\\\\\\\"BG\\\\\\\"],\\\\n            foreground=P[\\\\\\\"TEXT\\\\\\\"],\\\\n            font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 11)\\\\n        )\\\\n        style.map(\\\\n            \\\\\\\"Modern.TCheckbutton\\\\\\\",\\\\n            background=[(\\\\\\\"active\\\\\\\", P[\\\\\\\"BG\\\\\\\"])]\\\\n        )\\\\n        \\\\n        # 配置自定义控件\\\\n        if widgets:\\\\n            for widget_type, widget_list in widgets.items():\\\\n                if widget_type == \\\\\\\"text\\\\\\\":\\\\n                    for text_widget in widget_list:\\\\n                        text_widget.configure(\\\\n                            bg=P[\\\\\\\"LOG_BG\\\\\\\"],\\\\n                            fg=P[\\\\\\\"TEXT\\\\\\\"],\\\\n                            insertbackground=P[\\\\\\\"TEXT\\\\\\\"],\\\\n                            font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 10)\\\\n                        )\\\\n                elif widget_type == \\\\\\\"canvas\\\\\\\":\\\\n                    for canvas in widget_list:\\\\n                        canvas.configure(bg=P[\\\\\\\"CARD\\\\\\\"])\\\\n\\\\n# ---------- 图像预览管理器 ----------\\\\nclass ImagePreviewManager:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"图像预览管理器 - 负责处理和显示图像预览\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    \\\\n    def __init__(self, canvas, theme_manager):\\\\n        self.canvas = canvas\\\\n        self.theme_manager = theme_manager\\\\n        self.current_image = None\\\\n        self.current_thumb = None\\\\n        self.current_info = None\\\\n        \\\\n        # 绑定画布调整事件\\\\n        self.canvas.bind(\\\\\\\"<Configure>\\\\\\\", self._on_canvas_resize)\\\\n    \\\\n    def _on_canvas_resize(self, event):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"画布大小改变时重新显示预览\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if self.current_image:\\\\n            self.show_preview(self.current_image, self.current_info)\\\\n    \\\\n    def show_preview(self, image_path, info=None):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"显示图像预览\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.current_image = image_path\\\\n        self.current_info = info\\\\n        \\\\n        try:\\\\n            # 清空画布\\\\n            self.canvas.delete(\\\\\\\"all\\\\\\\")\\\\n            \\\\n            # 检查文件是否存在且为图像\\\\n            if not os.path.exists(image_path) or not is_image_ext(image_path.split(\\\\\\\".\\\\\\\")[-1]):\\\\n                self._show_placeholder(\\\\\\\"不支持预览此文件类型\\\\\\\")\\\\n                return\\\\n            \\\\n            # 尝试打开图像\\\\n            with Image.open(image_path) as img:\\\\n                # 获取画布尺寸\\\\n                canvas_width = self.canvas.winfo_width()\\\\n                canvas_height = self.canvas.winfo_height()\\\\n                \\\\n                if canvas_width <= 10 or canvas_height <= 10:  # 画布尚未渲染\\\\n                    return\\\\n                \\\\n                # 计算缩放比例\\\\n                max_size = (canvas_width - 40, canvas_height - 80)  # 留出边距\\\\n                img.thumbnail(max_size, Image.Resampling.LANCZOS)\\\\n                \\\\n                # 创建缩略图\\\\n                self.current_thumb = ImageTk.PhotoImage(img)\\\\n                \\\\n                # 显示图像（居中）\\\\n                x = (canvas_width - self.current_thumb.width()) // 2\\\\n                y = (canvas_height - self.current_thumb.height() - 40) // 2  # 留出底部信息空间\\\\n                self.canvas.create_image(x, y, anchor=tk.CENTER, image=self.current_thumb)\\\\n                \\\\n                # 绘制文件名\\\\n                filename = os.path.basename(image_path)\\\\n                self.canvas.create_text(\\\\n                    canvas_width // 2, \\\\n                    canvas_height - 50, \\\\n                    text=filename, \\\\n                    fill=self.theme_manager.THEMES[\\\\\\\"light\\\\\\\"][\\\\\\\"TEXT\\\\\\\"],  # 简化处理，实际应根据当前主题获取\\\\n                    font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 10, \\\\\\\"bold\\\\\\\"),\\\\n                    width=canvas_width - 40\\\\n                )\\\\n                \\\\n                # 绘制文件信息\\\\n                if info:\\\\n                    self.canvas.create_text(\\\\n                        canvas_width // 2, \\\\n                        canvas_height - 25, \\\\n                        text=info, \\\\n                        fill=self.theme_manager.THEMES[\\\\\\\"light\\\\\\\"][\\\\\\\"TEXT_SECONDARY\\\\\\\"],\\\\n                        font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 9),\\\\n                        width=canvas_width - 40\\\\n                    )\\\\n        \\\\n        except Exception as e:\\\\n            self._show_placeholder(\\\\\\\"无法预览图像\\\\\\\")\\\\n    \\\\n    def _show_placeholder(self, text):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"显示占位符\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.canvas.delete(\\\\\\\"all\\\\\\\")\\\\n        canvas_width = self.canvas.winfo_width()\\\\n        canvas_height = self.canvas.winfo_height()\\\\n        \\\\n        # 绘制占位符图标（简化为文本）\\\\n        self.canvas.create_text(\\\\n            canvas_width // 2, \\\\n            canvas_height // 2, \\\\n            text=\\\\\\\"📷\\\\\\\", \\\\n            font=(\\\\\\\"Arial\\\\\\\", 48)\\\\n        )\\\\n        \\\\n        # 绘制提示文本\\\\n        self.canvas.create_text(\\\\n            canvas_width // 2, \\\\n            canvas_height // 2 + 40, \\\\n            text=text, \\\\n            fill=self.theme_manager.THEMES[\\\\\\\"light\\\\\\\"][\\\\\\\"TEXT_SECONDARY\\\\\\\"],\\\\n            font=(\\\\\\\"Microsoft YaHei UI\\\\\\\", 11)\\\\n        )\\\\n    \\\\n    def clear_preview(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"清除预览\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.canvas.delete(\\\\\\\"all\\\\\\\")\\\\n        self.current_image = None\\\\n        self.current_thumb = None\\\\n        self.current_info = None\\\\n        self._show_placeholder(\\\\\\\"等待预览\\\\\\\")\\\\n\\\\n# ---------- 复制管理器 ----------\\\\nclass CopyManager:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"复制管理器 - 处理文件复制逻辑，支持进度报告和预览更新\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    \\\\n    def __init__(self, log_widget, status_var, progress_var, preview_manager=None):\\\\n        self.log_widget = log_widget\\\\n        self.status_var = status_var\\\\n        self.progress_var = progress_var\\\\n        self.preview_manager = preview_manager\\\\n        self.stop_event = threading.Event()\\\\n        self.created_files = []\\\\n    \\\\n    def start_copy(self, src_drive, dst_letter, cfg, root, category, extract_star=False):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"开始复制过程\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 重置状态\\\\n        self.stop_event.clear()\\\\n        self.created_files = []\\\\n        \\\\n        # 创建并启动线程\\\\n        copy_thread = threading.Thread(\\\\n            target=self._copy_thread,\\\\n            args=(src_drive, dst_letter, cfg, root, category, extract_star)\\\\n        )\\\\n        copy_thread.daemon = True\\\\n        copy_thread.start()\\\\n        \\\\n        return copy_thread\\\\n    \\\\n    def stop_copy(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"停止复制过程\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.stop_event.set()\\\\n    \\\\n    def _copy_thread(self, src_drive, dst_letter, cfg, root, category, extract_star):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"复制线程函数\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # 1. 收集信息和创建目录\\\\n            log_add(self.log_widget, f\\\\\\\"素材盘：{src_drive}（{get_drive_label(src_drive)} | {drive_type_name(get_drive_type_code(src_drive))}）\\\\\\\")\\\\n            \\\\n            # 2. 获取拍摄名称\\\\n            shoot_name = None\\\\n            def ask_name():\\\\n                nonlocal shoot_name\\\\n                shoot_name = simpledialog.askstring(\\\\\\\"本次拍摄名称\\\\\\\", \\\\\\\"输入拍摄地点或主题（可中文）：\\\\\\\", parent=root)\\\\n            root.after(0, ask_name)\\\\n            \\\\n            # 等待用户输入\\\\n            while shoot_name is None and not self.stop_event.is_set():\\\\n                time.sleep(0.1)\\\\n            \\\\n            if self.stop_event.is_set() or not shoot_name:\\\\n                root.after(0, lambda: log_add(self.log_widget, \\\\\\\"用户取消操作\\\\\\\"))\\\\n                return\\\\n            \\\\n            # 3. 预检文件\\\\n            root.after(0, lambda: log_add(self.log_widget, \\\\\\\"开始预检源文件…\\\\\\\"))\\\\n            counts, sizes, files = preflight_scan(src_drive)\\\\n            total_files = counts[\\\\\\\"RAW\\\\\\\"] + counts[\\\\\\\"JPG\\\\\\\"] + counts[\\\\\\\"VIDEO\\\\\\\"]\\\\n            total_size = sizes[\\\\\\\"RAW\\\\\\\"] + sizes[\\\\\\\"JPG\\\\\\\"] + sizes[\\\\\\\"VIDEO\\\\\\\"]\\\\n            \\\\n            root.after(0, lambda: log_add(self.log_widget, \\\\n                f\\\\\\\"预检完成 RAW:{counts[\\\\'RAW\\\\']} JPG:{counts[\\\\'JPG\\\\']} VIDEO:{counts[\\\\'VIDEO\\\\']} 合计:{total_files} | 体积 {bytes_to_human(total_size)}\\\\\\\"))\\\\n            \\\\n            # 4. 确认对话框\\\\n            confirm = False\\\\n            def show_confirm():\\\\n                nonlocal confirm\\\\n                confirm = messagebox.askyesno(\\\\n                    \\\\\\\"确认复制\\\\\\\",\\\\n                    f\\\\\\\"预检完成：\\\\\\\\n\\\\\\\"\\\\n                f\\\\\\\"RAW：{counts[\\\\'RAW\\\\']}（{bytes_to_human(sizes[\\\\'RAW\\\\'])}）\\\\\\\\n\\\\\\\"\\\\n                f\\\\\\\"JPG：{counts[\\\\'JPG\\\\']}（{bytes_to_human(sizes[\\\\'JPG\\\\'])}）\\\\\\\\n\\\\\\\"\\\\n                f\\\\\\\"VIDEO：{counts[\\\\'VIDEO\\\\']}（{bytes_to_human(sizes[\\\\'VIDEO\\\\'])}）\\\\\\\\n\\\\\\\"\\\\n                f\\\\\\\"合计：{total_files}（{bytes_to_human(total_size)}）\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n                f\\\\\\\"将复制到：年/拍摄类型/MM月/MM.DD_拍摄名/（RAW,JPG,VIDEO，及可选已星标照片）\\\\\\\\n\\\\\\\"\\\\n                f\\\\\\\"照片重命名：MMDD-0001 起；视频保留原名。\\\\\\\"\\\\n                )\\\\n            root.after(0, show_confirm)\\\\n            \\\\n            # 等待用户确认\\\\n            while confirm is None and not self.stop_event.is_set():\\\\n                time.sleep(0.1)\\\\n            \\\\n            if self.stop_event.is_set() or not confirm:\\\\n                root.after(0, lambda: log_add(self.log_widget, \\\\\\\"用户取消复制\\\\\\\"))\\\\n                return\\\\n            \\\\n            # 5. 确定目标目录\\\\n            if dst_letter:\\\\n                target_root = dst_letter + \\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\"\\\\n            else:\\\\n                target_root = cfg.get(\\\\\\\"last_target_root\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                if not os.path.exists(target_root):\\\\n                    def ask_dir():\\\\n                        nonlocal target_root\\\\n                        target_root = filedialog.askdirectory(title=\\\\\\\"选择目标硬盘文件夹（建议为外置硬盘根目录）\\\\\\\")\\\\n                    root.after(0, ask_dir)\\\\n                    \\\\n                    while target_root is None and not self.stop_event.is_set():\\\\n                        time.sleep(0.1)\\\\n                    \\\\n                    if self.stop_event.is_set() or not target_root:\\\\n                        root.after(0, lambda: log_add(self.log_widget, \\\\\\\"用户取消操作\\\\\\\"))\\\\n                        return\\\\n            \\\\n            cfg[\\\\\\\"last_target_root\\\\\\\"] = target_root\\\\n            save_config(cfg)\\\\n            \\\\n            # 检查目标盘与源盘是否相同\\\\n            if os.path.splitdrive(target_root)[0].upper() == os.path.splitdrive(src_drive)[0].upper():\\\\n                same_drive = False\\\\n                def ask_same_drive():\\\\n                    nonlocal same_drive\\\\n                    same_drive = messagebox.askyesno(\\\\\\\"风险提示\\\\\\\", \\\\\\\"目标盘与素材盘相同盘符，建议不同物理盘。继续？\\\\\\\")\\\\n                root.after(0, ask_same_drive)\\\\n                \\\\n                while same_drive is None and not self.stop_event.is_set():\\\\n                    time.sleep(0.1)\\\\n                \\\\n                if self.stop_event.is_set() or not same_drive:\\\\n                    root.after(0, lambda: log_add(self.log_widget, \\\\\\\"用户取消操作\\\\\\\"))\\\\n                    return\\\\n            \\\\n            # 6. 创建目标目录结构\\\\n            today = datetime.now()\\\\n            year_dir = os.path.join(target_root, str(today.year))\\\\n            cat_dir = os.path.join(year_dir, category)\\\\n            month_dir = os.path.join(cat_dir, f\\\\\\\"{today.month:02d}月\\\\\\\")\\\\n            day_folder = f\\\\\\\"{today.month:02d}.{today.day:02d}_{shoot_name}\\\\\\\"\\\\n            target_dir = os.path.join(month_dir, day_folder)\\\\n            \\\\n            os.makedirs(target_dir, exist_ok=True)\\\\n            root.after(0, lambda: log_add(self.log_widget, f\\\\\\\"目标目录：{target_dir}\\\\\\\"))\\\\n            \\\\n            # 7. 检查目标空间\\\\n            try:\\\\n                _, dst_free = get_drive_usage_bytes(os.path.splitdrive(target_root)[0] + \\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\")\\\\n                if dst_free < total_size:\\\\n                    root.after(0, lambda: log_add(self.log_widget, \\\\n                        f\\\\\\\"目标剩余 {bytes_to_human(dst_free)} < 需要 {bytes_to_human(total_size)}\\\\\\\"))\\\\n                    \\\\n                    space_ok = False\\\\n                    def ask_space():\\\\n                        nonlocal space_ok\\\\n                        space_ok = messagebox.askretrycancel(\\\\n                            \\\\\\\"空间不足\\\\\\\",\\\\n                            f\\\\\\\"目标剩余 {bytes_to_human(dst_free)}，预计需要 {bytes_to_human(total_size)}。清理后重试。\\\\\\\"\\\\n                        )\\\\n                    root.after(0, ask_space)\\\\n                    \\\\n                    while space_ok is None and not self.stop_event.is_set():\\\\n                        time.sleep(0.1)\\\\n                    \\\\n                    if self.stop_event.is_set() or not space_ok:\\\\n                        root.after(0, lambda: log_add(self.log_widget, \\\\\\\"空间不足，取消操作\\\\\\\"))\\\\n                        return\\\\n            except Exception:\\\\n                pass\\\\n            \\\\n            # 8. 准备复制\\\\n            log_file = os.path.join(target_dir, \\\\\\\"copy_log.txt\\\\\\\")\\\\n            mmdd_str = f\\\\\\\"{today.month:02d}{today.day:02d}\\\\\\\"\\\\n            \\\\n            # 初始化进度条\\\\n            root.after(0, lambda: self.progress_var.set(0))\\\\n            root.after(0, lambda: self.status_var.set(\\\\\\\"准备复制…\\\\\\\"))\\\\n            \\\\n            # 开始提示音\\\\n            beep_start()\\\\n            root.after(0, lambda: log_add(self.log_widget, \\\\\\\"开始复制…\\\\\\\"))\\\\n            \\\\n            # 9. 执行复制\\\\n            self._copy_files(files, target_dir, log_file, mmdd_str, total_size, extract_star, root)\\\\n            \\\\n            # 10. 完成操作\\\\n            if not self.stop_event.is_set():\\\\n                root.after(0, lambda: log_add(self.log_widget, f\\\\\\\"复制完成 共 {len(self.created_files)} 个目标文件\\\\\\\"))\\\\n                root.after(0, lambda: self.status_var.set(\\\\\\\"复制完成\\\\\\\"))\\\\n                \\\\n                # 创建清单文件\\\\n                ts2 = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                manifest = {\\\\n                    \\\\\\\"version\\\\\\\": VERSION,\\\\n                    \\\\\\\"created_at\\\\\\\": ts2,\\\\n                    \\\\\\\"source_drive\\\\\\\": src_drive,\\\\n                    \\\\\\\"target_dir\\\\\\\": target_dir,\\\\n                    \\\\\\\"files\\\\\\\": self.created_files\\\\n                }\\\\n                \\\\n                try:\\\\n                    with open(os.path.join(target_dir, f\\\\\\\"import_manifest_{ts2}.json\\\\\\\"), \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                        json.dump(manifest, f, ensure_ascii=False, indent=2)\\\\n                except Exception:\\\\n                    pass\\\\n                \\\\n                # 完成提示音\\\\n                beep_done()\\\\n                \\\\n                # 显示完成窗口\\\\n                root.after(0, lambda: self._show_finish_window(root, target_dir))\\\\n            else:\\\\n                root.after(0, lambda: self.status_var.set(\\\\\\\"已停止\\\\\\\"))\\\\n                root.after(0, lambda: log_add(self.log_widget, \\\\\\\"复制已停止\\\\\\\"))\\\\n        \\\\n        except Exception as e:\\\\n            root.after(0, lambda: log_add(self.log_widget, f\\\\\\\"错误：{str(e)}\\\\\\\"))\\\\n            root.after(0, lambda: self.status_var.set(\\\\\\\"错误\\\\\\\"))\\\\n    \\\\n    def _copy_files(self, src_files, dst, log_file, mmdd_str, total_bytes, extract_star, root):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"执行文件复制，显示进度和预览\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        created = []; done = set()\\\\n        \\\\n        # 读取已完成的文件\\\\n        if os.path.exists(log_file):\\\\n            try:\\\\n                with open(log_file, \\\\\\\"r\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                    for line in f:\\\\n                        if line.startswith(\\\\\\\"完成: \\\\\\\"):\\\\n                            done.add(line.split(\\\\\\\"完成: \\\\\\\", 1)[1].split(\\\\\\\" -> \\\\\\\", 1)[0].strip())\\\\n            except Exception:\\\\n                pass\\\\n        \\\\n        # 准备目标目录\\\\n        photo_files = src_files[\\\\\\\"RAW\\\\\\\"] + src_files[\\\\\\\"JPG\\\\\\\"]\\\\n        video_files = src_files[\\\\\\\"VIDEO\\\\\\\"]\\\\n        \\\\n        raw_dir = os.path.join(dst, \\\\\\\"RAW\\\\\\\")\\\\n        jpg_dir = os.path.join(dst, \\\\\\\"JPG\\\\\\\")\\\\n        vid_dir = os.path.join(dst, \\\\\\\"VIDEO\\\\\\\")\\\\n        \\\\n        os.makedirs(raw_dir, exist_ok=True)\\\\n        os.makedirs(jpg_dir, exist_ok=True)\\\\n        os.makedirs(vid_dir, exist_ok=True)\\\\n        \\\\n        # 准备星标目录\\\\n        star_root = os.path.join(dst, \\\\\\\"已星标照片\\\\\\\")\\\\n        star_jpg = os.path.join(star_root, \\\\\\\"已星标JPG\\\\\\\")\\\\n        star_raw = os.path.join(star_root, \\\\\\\"已星标RAW\\\\\\\")\\\\n        \\\\n        if extract_star:\\\\n            os.makedirs(star_jpg, exist_ok=True)\\\\n            os.makedirs(star_raw, exist_ok=True)\\\\n        \\\\n        # 构建照片重命名计划\\\\n        plan = build_seq_plan(photo_files, mmdd_str)\\\\n        final_map = {}\\\\n        \\\\n        bytes_done = 0\\\\n        t0 = time.time()\\\\n        last_preview_update = 0\\\\n        \\\\n        # 更新状态函数\\\\n        def update_status(label_text):\\\\n            elapsed = max(time.time() - t0, 1e-6)\\\\n            speed_mb = bytes_done / elapsed / (1024 * 1024)\\\\n            pct = (bytes_done / total_bytes * 100) if total_bytes > 0 else 0\\\\n            \\\\n            root.after(0, lambda: self.progress_var.set(min(max(pct, 0), 100)))\\\\n            root.after(0, lambda: self.status_var.set(\\\\n                f\\\\\\\"{label_text} | {bytes_to_human(bytes_done)} / {bytes_to_human(total_bytes)} | 速度 {speed_mb:.2f} MB/s\\\\\\\"\\\\n            ))\\\\n        \\\\n        # 1. 复制照片\\\\n        for src, base, ext in plan:\\\\n            if self.stop_event.is_set():\\\\n                return\\\\n            \\\\n            if src in done:\\\\n                update_status(\\\\\\\"照片\\\\\\\")\\\\n                continue\\\\n            \\\\n            td = raw_dir if is_raw_ext(ext) else jpg_dir\\\\n            dst_path = unique_path(td, f\\\\\\\"{base}.{ext}\\\\\\\")\\\\n            \\\\n            try:\\\\n                size = 0\\\\n                try: size = os.path.getsize(src)\\\\n                except Exception: size = 0\\\\n                \\\\n                shutil.copy2(src, dst_path)\\\\n                created.append(dst_path)\\\\n                final_map[src] = dst_path\\\\n                \\\\n                with open(log_file, \\\\\\\"a\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                    f.write(f\\\\\\\"完成: {src} -> {os.path.basename(dst_path)}\\\\\\\\n\\\\\\\")\\\\n                \\\\n                bytes_done += size\\\\n                update_status(\\\\\\\"照片\\\\\\\")\\\\n                \\\\n                # 更新日志和预览（降低频率）\\\\n                current_time = time.time()\\\\n                if current_time - last_preview_update > 1:  # 每秒最多更新一次预览\\\\n                    root.after(0, lambda dst=dst_path: log_add(self.log_widget, f\\\\\\\"复制：{os.path.basename(dst)}\\\\\\\"))\\\\n                    \\\\n                    if self.preview_manager and is_jpg_ext(ext):  # 只预览JPG以提高性能\\\\n                        file_info = f\\\\\\\"{bytes_to_human(size)} | {os.path.basename(dst)}\\\\\\\"\\\\n                        root.after(0, lambda src=src, info=file_info: self.preview_manager.show_preview(src, info))\\\\n                    \\\\n                    last_preview_update = current_time\\\\n                    \\\\n            except Exception as e:\\\\n                with open(log_file, \\\\\\\"a\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                    f.write(f\\\\\\\"错误: {src} | {e}\\\\\\\\n\\\\\\\")\\\\n        \\\\n        # 2. 复制视频\\\\n        for src in video_files:\\\\n            if self.stop_event.is_set():\\\\n                return\\\\n            \\\\n            if src in done:\\\\n                update_status(\\\\\\\"视频\\\\\\\")\\\\n                continue\\\\n            \\\\n            dst_path = unique_path(vid_dir, os.path.basename(src))\\\\n            \\\\n            try:\\\\n                size = 0\\\\n                try: size = os.path.getsize(src)\\\\n                except Exception: size = 0\\\\n                \\\\n                shutil.copy2(src, dst_path)\\\\n                created.append(dst_path)\\\\n                \\\\n                with open(log_file, \\\\\\\"a\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                    f.write(f\\\\\\\"完成: {src} -> {os.path.basename(dst_path)}\\\\\\\\n\\\\\\\")\\\\n                \\\\n                bytes_done += size\\\\n                update_status(\\\\\\\"视频\\\\\\\")\\\\n                \\\\n                # 更新日志（降低频率）\\\\n                current_time = time.time()\\\\n                if current_time - last_preview_update > 2:  # 视频更新频率更低\\\\n                    root.after(0, lambda dst=dst_path: log_add(self.log_widget, f\\\\\\\"复制视频：{os.path.basename(dst)}\\\\\\\"))\\\\n                    last_preview_update = current_time\\\\n                    \\\\n            except Exception as e:\\\\n                with open(log_file, \\\\\\\"a\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                    f.write(f\\\\\\\"错误: {src} | {e}\\\\\\\\n\\\\\\\")\\\\n        \\\\n        # 3. 提取星标照片\\\\n        if extract_star and not self.stop_event.is_set():\\\\n            root.after(0, lambda: log_add(self.log_widget, \\\\\\\"开始提取星标照片…\\\\\\\"))\\\\n            star_count = 0\\\\n            \\\\n            for src, base, ext in plan:\\\\n                if self.stop_event.is_set():\\\\n                    return\\\\n                \\\\n                try:\\\\n                    if is_starred_file(src):\\\\n                        src_copied_path = final_map.get(src, src)\\\\n                        if is_jpg_ext(ext):\\\\n                            dst_star = unique_path(star_jpg, os.path.basename(src_copied_path))\\\\n                        else:\\\\n                            dst_star = unique_path(star_raw, os.path.basename(src_copied_path))\\\\n                        \\\\n                        shutil.copy2(src_copied_path, dst_star)\\\\n                        created.append(dst_star)\\\\n                        star_count += 1\\\\n                        \\\\n                        # 偶尔更新日志\\\\n                        if star_count % 5 == 0:\\\\n                            root.after(0, lambda cnt=star_count: log_add(self.log_widget, f\\\\\\\"已提取 {cnt} 个星标照片\\\\\\\"))\\\\n                            \\\\n                except Exception as e:\\\\n                    with open(log_file, \\\\\\\"a\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                        f.write(f\\\\\\\"星标复制错误: {src} | {e}\\\\\\\\n\\\\\\\")\\\\n            \\\\n            root.after(0, lambda cnt=star_count: log_add(self.log_widget, f\\\\\\\"星标提取完成，共 {cnt} 个文件\\\\\\\"))\\\\n        \\\\n        # 更新进度到100%\\\\n        root.after(0, lambda: self.progress_var.set(100))\\\\n        root.after(0, lambda: self.status_var.set(\\\\\\\"完成\\\\\\\"))\\\\n        \\\\n        # 保存创建的文件列表\\\\n        self.created_files = created\\\\n    \\\\n    def _show_finish_window(self, root, target_dir):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"显示完成窗口\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        win = tk.Toplevel(root)\\\\n        win.title(\\\\\\\"完成\\\\\\\")\\\\n        win.resizable(False, False)\\\\n        win.transient(root)      # 置于父窗口上方\\\\n        win.grab_set()           # 获取焦点\\\\n        \\\\n        # 加载配置并应用主题\\\\n        try:\\\\n            theme_key = load_config().get(\\\\\\\"theme\\\\\\\", \\\\\\\"light\\\\\\\")\\\\n            ThemeManager.apply_theme(win, theme_key)\\\\n        except Exception:\\\\n            pass\\\\n        \\\\n        # 窗口样式\\\\n        P = ThemeManager.THEMES[\\\\\\\"dark\\\\\\\" if theme_key == \\\\\\\"dark\\\\\\\" else \\\\\\\"light\\\\\\\"]\\\\n        win.configure(bg=P[\\\\\\\"BG\\\\\\\"])\\\\n        \\\\n        # 添加卡片效果（通过Frame实现）\\\\n        card = ttk.Frame(win, style=\\\\\\\"Modern.Card.TFrame\\\\\\\", padding=24)\\\\n        card.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)\\\\n        \\\\n        # 标题\\\\n        ttk.Label(card, text=\\\\\\\"导入完成\\\\\\\", style=\\\\\\\"Modern.Title.TLabel\\\\\\\").pack(anchor=\\\\\\\"w\\\\\\\", pady=(0, 16))\\\\n        \\\\n        # 信息\\\\n        info_frame = ttk.Frame(card, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        info_frame.pack(fill=tk.X, pady=(0, 24))\\\\n        \\\\n        ttk.Label(info_frame, text=\\\\\\\"输出目录：\\\\\\\", style=\\\\\\\"Modern.Body.TLabel\\\\\\\").grid(row=0, column=0, sticky=\\\\\\\"w\\\\\\\", pady=(0, 4))\\\\n        ttk.Label(info_frame, text=target_dir, style=\\\\\\\"Modern.Secondary.TLabel\\\\\\\").grid(row=0, column=1, sticky=\\\\\\\"w\\\\\\\", pady=(0, 4))\\\\n        \\\\n        # 按钮区域\\\\n        btn_frame = ttk.Frame(card, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        btn_frame.pack(fill=tk.X, anchor=\\\\\\\"e\\\\\\\")\\\\n        \\\\n        def open_folder():\\\\n            _open_folder(target_dir)\\\\n            win.destroy()\\\\n        \\\\n        def undo():\\\\n            removed = 0\\\\n            for p in self.created_files:\\\\n                try:\\\\n                    if os.path.isfile(p):\\\\n                        os.remove(p); removed += 1\\\\n                except Exception:\\\\n                    pass\\\\n            \\\\n            # 清理空目录\\\\n            for sub in [\\\\\\\"RAW\\\\\\\", \\\\\\\"JPG\\\\\\\", \\\\\\\"VIDEO\\\\\\\", \\\\\\\"已星标照片\\\\\\\", \\\\\\\"已星标照片\\\\\\\\\\\\\\\\已星标JPG\\\\\\\", \\\\\\\"已星标照片\\\\\\\\\\\\\\\\已星标RAW\\\\\\\"]:\\\\n                d = os.path.join(target_dir, sub)\\\\n                try:\\\\n                    if os.path.isdir(d) and not os.listdir(d):\\\\n                        os.rmdir(d)\\\\n                except Exception:\\\\n                    pass\\\\n            \\\\n            try:\\\\n                if os.path.isdir(target_dir) and not os.listdir(target_dir):\\\\n                    os.rmdir(target_dir)\\\\n            except Exception:\\\\n                pass\\\\n            \\\\n            messagebox.showinfo(\\\\\\\"撤销完成\\\\\\\", f\\\\\\\"已删除本次导入生成的 {removed} 个文件。\\\\\\\")\\\\n            win.destroy()\\\\n        \\\\n        # 创建按钮\\\\n        ttk.Button(btn_frame, text=\\\\\\\"关闭\\\\\\\", style=\\\\\\\"Modern.Secondary.TButton\\\\\\\", command=win.destroy).pack(side=tk.RIGHT, padx=(0, 8))\\\\n        ttk.Button(btn_frame, text=\\\\\\\"撤销本次导入\\\\\\\", style=\\\\\\\"Modern.Secondary.TButton\\\\\\\", command=undo).pack(side=tk.RIGHT, padx=(0, 8))\\\\n        ttk.Button(btn_frame, text=\\\\\\\"打开输出文件夹\\\\\\\", style=\\\\\\\"Modern.Primary.TButton\\\\\\\", command=open_folder).pack(side=tk.RIGHT)\\\\n        \\\\n        # 计算尺寸后居中到父窗口\\\\n        win.update_idletasks()\\\\n        self._center_on_parent(win, root)\\\\n    \\\\n    def _center_on_parent(self, child: tk.Toplevel, parent: tk.Tk):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"把子窗口居中到父窗口\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        parent.update_idletasks()\\\\n        child.update_idletasks()\\\\n        \\\\n        pw, ph = parent.winfo_width(), parent.winfo_height()\\\\n        px, py = parent.winfo_rootx(), parent.winfo_rooty()\\\\n        cw, ch = child.winfo_width(), child.winfo_height()\\\\n        \\\\n        x = px + max((pw - cw) // 2, 0)\\\\n        y = py + max((ph - ch) // 2, 0)\\\\n        \\\\n        child.geometry(f\\\\\\\"+{x}+{y}\\\\\\\")\\\\n\\\\n# ---------- 主应用类 ----------\\\\nclass ModernPhotoSorterApp:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"现代UI版本的影像管理助手应用程序\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    \\\\n    def __init__(self):\\\\n        # 加载配置\\\\n        self.cfg = load_config()\\\\n        self.theme_key = self.cfg.get(\\\\\\\"theme\\\\\\\", \\\\\\\"light\\\\\\\")\\\\n        self.sash_ratio = float(self.cfg.get(\\\\\\\"sash_ratio\\\\\\\", 0.55))\\\\n        \\\\n        # 创建主窗口\\\\n        self.root = tk.Tk()\\\\n        self.root.title(f\\\\\\\"陈同学影像管理助手  {VERSION}\\\\\\\")\\\\n        \\\\n        # 恢复窗口位置和大小\\\\n        pos = self.cfg.get(\\\\\\\"window_pos\\\\\\\", {\\\\\\\"x\\\\\\\": 100, \\\\\\\"y\\\\\\\": 100})\\\\n        size = self.cfg.get(\\\\\\\"window_size\\\\\\\", {\\\\\\\"width\\\\\\\": 1000, \\\\\\\"height\\\\\\\": 720})\\\\n        self.root.geometry(f\\\\\\\"{size[\\\\'width\\\\']}x{size[\\\\'height\\\\']}+{pos[\\\\'x\\\\']}+{pos[\\\\'y\\\\']}\\\\\\\")\\\\n        self.root.minsize(900, 650)\\\\n        \\\\n        # 应用主题\\\\n        self.theme_manager = ThemeManager\\\\n        self.theme_manager.apply_theme(self.root, self.theme_key)\\\\n        \\\\n        # 创建UI组件\\\\n        self._create_ui()\\\\n        \\\\n        # 初始化数据\\\\n        self._initialize_data()\\\\n        \\\\n        # 绑定事件\\\\n        self._bind_events()\\\\n    \\\\n    def _create_ui(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"创建用户界面\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 顶部栏\\\\n        header = ttk.Frame(self.root, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        header.pack(fill=tk.X, padx=24, pady=(16, 0))\\\\n        \\\\n        # 标题和主题选择\\\\n        title_frame = ttk.Frame(header, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        title_frame.pack(fill=tk.X)\\\\n        \\\\n        ttk.Label(title_frame, text=\\\\\\\"照片/视频导入与分类\\\\\\\", style=\\\\\\\"Modern.Title.TLabel\\\\\\\").pack(side=tk.LEFT)\\\\n        \\\\n        theme_frame = ttk.Frame(title_frame, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        theme_frame.pack(side=tk.RIGHT, pady=8)\\\\n        \\\\n        ttk.Label(theme_frame, text=\\\\\\\"主题:\\\\\\\", style=\\\\\\\"Modern.Body.TLabel\\\\\\\").pack(side=tk.LEFT, padx=(0, 8))\\\\n        \\\\n        self.theme_box = ttk.Combobox(\\\\n            theme_frame, \\\\n            state=\\\\\\\"readonly\\\\\\\", \\\\n            values=THEMES, \\\\n            width=8,\\\\n            style=\\\\\\\"Modern.TCombobox\\\\\\\"\\\\n        )\\\\n        self.theme_box.pack(side=tk.LEFT)\\\\n        self.theme_box.set(\\\\\\\"日间\\\\\\\" if self.theme_key == \\\\\\\"light\\\\\\\" else \\\\\\\"暗黑\\\\\\\")\\\\n        \\\\n        # 主内容区域 - 使用PanedWindow实现可拖动分割\\\\n        self.paned = ttk.Panedwindow(self.root, orient=\\\\\\\"vertical\\\\\\\")\\\\n        self.paned.pack(fill=tk.BOTH, expand=True, padx=24, pady=(16, 8))\\\\n        \\\\n        # 上部：设置区域\\\\n        self.top_frame = ttk.Frame(self.paned, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        self.paned.add(self.top_frame, weight=3)\\\\n        \\\\n        # 下部：日志和预览区域\\\\n        self.bottom_frame = ttk.Frame(self.paned, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        self.paned.add(self.bottom_frame, weight=5)\\\\n        \\\\n        # ----- 上部设置区域 ----- #\\\\n        # 导入设置卡片\\\\n        import_card = ttk.Frame(self.top_frame, style=\\\\\\\"Modern.Card.TFrame\\\\\\\", padding=20)\\\\n        import_card.pack(fill=tk.X, pady=(0, 12))\\\\n        \\\\n        ttk.Label(import_card, text=\\\\\\\"导入设置\\\\\\\", style=\\\\\\\"Modern.Subtitle.TLabel\\\\\\\").pack(anchor=\\\\\\\"w\\\\\\\", pady=(0, 16))\\\\n        \\\\n        # 表单布局\\\\n        form_frame = ttk.Frame(import_card, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        form_frame.pack(fill=tk.X)\\\\n        \\\\n        # 素材盘选择\\\\n        self._create_form_row(form_frame, \\\\\\\"选择素材盘\\\\\\\", 0)\\\\n        \\\\n        self.combo_src = ttk.Combobox(\\\\n            form_frame,\\\\n            state=\\\\\\\"readonly\\\\\\\",\\\\n            width=60,\\\\n            style=\\\\\\\"Modern.TCombobox\\\\\\\"\\\\n        )\\\\n        self.combo_src.grid(row=0, column=1, sticky=\\\\\\\"ew\\\\\\\", padx=(8, 12))\\\\n        \\\\n        self.btn_refresh_src = ttk.Button(\\\\n            form_frame,\\\\n            text=\\\\\\\"刷新\\\\\\\",\\\\n            style=\\\\\\\"Modern.Secondary.TButton\\\\\\\",\\\\n            command=lambda: self.refresh_sources(auto_pick=True)\\\\n        )\\\\n        self.btn_refresh_src.grid(row=0, column=2, padx=(0, 8))\\\\n        \\\\n        # 目标盘选择\\\\n        self._create_form_row(form_frame, \\\\\\\"拷入到\\\\\\\", 1)\\\\n        \\\\n        self.combo_dst = ttk.Combobox(\\\\n            form_frame,\\\\n            state=\\\\\\\"readonly\\\\\\\",\\\\n            width=60,\\\\n            style=\\\\\\\"Modern.TCombobox\\\\\\\"\\\\n        )\\\\n        self.combo_dst.grid(row=1, column=1, sticky=\\\\\\\"ew\\\\\\\", padx=(8, 12), pady=(12, 0))\\\\n        \\\\n        self.btn_refresh_dst = ttk.Button(\\\\n            form_frame,\\\\n            text=\\\\\\\"刷新\\\\\\\",\\\\n            style=\\\\\\\"Modern.Secondary.TButton\\\\\\\",\\\\n            command=self.refresh_dests\\\\n        )\\\\n        self.btn_refresh_dst.grid(row=1, column=2, padx=(0, 8), pady=(12, 0))\\\\n        \\\\n        # 拍摄类型和星标选项\\\\n        self._create_form_row(form_frame, \\\\\\\"拍摄类型\\\\\\\", 2)\\\\n        \\\\n        self.combo_cat = ttk.Combobox(\\\\n            form_frame,\\\\n            state=\\\\\\\"readonly\\\\\\\",\\\\n            values=CATEGORIES,\\\\n            width=20,\\\\n            style=\\\\\\\"Modern.TCombobox\\\\\\\"\\\\n        )\\\\n        self.combo_cat.grid(row=2, column=1, sticky=\\\\\\\"w\\\\\\\", padx=(8, 12), pady=(12, 0))\\\\n        self.combo_cat.current(0)\\\\n        \\\\n        self.star_var = tk.BooleanVar(value=False)\\\\n        self.chk_star = ttk.Checkbutton(\\\\n            form_frame,\\\\n            text=\\\\\\\"提取星标照片\\\\\\\",\\\\n            variable=self.star_var,\\\\n            style=\\\\\\\"Modern.TCheckbutton\\\\\\\"\\\\n        )\\\\n        self.chk_star.grid(row=2, column=2, sticky=\\\\\\\"w\\\\\\\", padx=(0, 8), pady=(12, 0))\\\\n        \\\\n        # 配置列权重\\\\n        form_frame.columnconfigure(1, weight=1)\\\\n        \\\\n        # 操作区域卡片\\\\n        action_card = ttk.Frame(self.top_frame, style=\\\\\\\"Modern.Card.TFrame\\\\\\\", padding=20)\\\\n        action_card.pack(fill=tk.X)\\\\n        \\\\n        # 进度条\\\\n        self.progress_var = tk.DoubleVar(value=0)\\\\n        self.progress_bar = ttk.Progressbar(\\\\n            action_card,\\\\n            variable=self.progress_var,\\\\n            style=\\\\\\\"Modern.Horizontal.TProgressbar\\\\\\\",\\\\n            orient=\\\\\\\"horizontal\\\\\\\",\\\\n            length=0,  # 由fill=tk.X自动填充\\\\n            mode=\\\\\\\"determinate\\\\\\\"\\\\n        )\\\\n        self.progress_bar.pack(fill=tk.X, pady=(0, 8))\\\\n        \\\\n        # 状态标签\\\\n        self.status_var = tk.StringVar(value=\\\\\\\"待机\\\\\\\")\\\\n        self.status_label = ttk.Label(\\\\n            action_card,\\\\n            textvariable=self.status_var,\\\\n            style=\\\\\\\"Modern.Secondary.TLabel\\\\\\\"\\\\n        )\\\\n        self.status_label.pack(anchor=\\\\\\\"w\\\\\\\", pady=(0, 16))\\\\n        \\\\n        # 按钮区域\\\\n        btn_frame = ttk.Frame(action_card, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        btn_frame.pack(fill=tk.X, anchor=\\\\\\\"e\\\\\\\")\\\\n        \\\\n        self.btn_exit = ttk.Button(\\\\n            btn_frame,\\\\n            text=\\\\\\\"退出\\\\\\\",\\\\n            style=\\\\\\\"Modern.Secondary.TButton\\\\\\\",\\\\n            command=self.root.destroy\\\\n        )\\\\n        self.btn_exit.pack(side=tk.RIGHT, padx=(0, 8))\\\\n        \\\\n        self.btn_stop = ttk.Button(\\\\n            btn_frame,\\\\n            text=\\\\\\\"停止\\\\\\\",\\\\n            style=\\\\\\\"Modern.Secondary.TButton\\\\\\\",\\\\n            command=self.stop_action,\\\\n            state=tk.DISABLED\\\\n        )\\\\n        self.btn_stop.pack(side=tk.RIGHT, padx=(0, 8))\\\\n        \\\\n        self.btn_start = ttk.Button(\\\\n            btn_frame,\\\\n            text=\\\\\\\"开始分类\\\\\\\",\\\\n            style=\\\\\\\"Modern.Primary.TButton\\\\\\\",\\\\n            command=self.start_action\\\\n        )\\\\n        self.btn_start.pack(side=tk.RIGHT)\\\\n        \\\\n        # ----- 下部日志和预览区域 ----- #\\\\n        # 创建水平分割的面板\\\\n        self.bottom_paned = ttk.Panedwindow(self.bottom_frame, orient=\\\\\\\"horizontal\\\\\\\")\\\\n        self.bottom_paned.pack(fill=tk.BOTH, expand=True)\\\\n        \\\\n        # 左侧：预览区域\\\\n        preview_frame = ttk.Frame(self.bottom_paned, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        self.bottom_paned.add(preview_frame, weight=1)\\\\n        \\\\n        # 预览卡片\\\\n        preview_card = ttk.Frame(preview_frame, style=\\\\\\\"Modern.Card.TFrame\\\\\\\", padding=16)\\\\n        preview_card.pack(fill=tk.BOTH, expand=True, pady=(0, 12))\\\\n        \\\\n        ttk.Label(preview_card, text=\\\\\\\"图像预览\\\\\\\", style=\\\\\\\"Modern.Subtitle.TLabel\\\\\\\").pack(anchor=\\\\\\\"w\\\\\\\", pady=(0, 12))\\\\n        \\\\n        # 预览画布\\\\n        self.preview_canvas = tk.Canvas(\\\\n            preview_card,\\\\n            relief=\\\\\\\"flat\\\\\\\",\\\\n            highlightthickness=0\\\\n        )\\\\n        self.preview_canvas.pack(fill=tk.BOTH, expand=True)\\\\n        \\\\n        # 右侧：日志区域\\\\n        log_frame = ttk.Frame(self.bottom_paned, style=\\\\\\\"Modern.Frame.TFrame\\\\\\\")\\\\n        self.bottom_paned.add(log_frame, weight=1)\\\\n        \\\\n        # 日志卡片\\\\n        log_card = ttk.Frame(log_frame, style=\\\\\\\"Modern.Card.TFrame\\\\\\\", padding=16)\\\\n        log_card.pack(fill=tk.BOTH, expand=True, pady=(0, 12))\\\\n        \\\\n        ttk.Label(log_card, text=\\\\\\\"信息日志\\\\\\\", style=\\\\\\\"Modern.Subtitle.TLabel\\\\\\\").pack(anchor=\\\\\\\"w\\\\\\\", pady=(0, 12))\\\\n        \\\\n        # 日志文本框\\\\n        self.info_box = tk.Text(\\\\n            log_card,\\\\n            wrap=\\\\\\\"word\\\\\\\",\\\\n            bd=0,\\\\n            relief=\\\\\\\"flat\\\\\\\",\\\\n            state=\\\\\\\"disabled\\\\\\\",\\\\n            highlightthickness=0\\\\n        )\\\\n        self.info_box.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)\\\\n        \\\\n        # 滚动条\\\\n        self.log_scrollbar = ttk.Scrollbar(\\\\n            log_card,\\\\n            command=self.info_box.yview\\\\n        )\\\\n        self.log_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\\\\n        \\\\n        self.info_box.configure(yscrollcommand=self.log_scrollbar.set)\\\\n        \\\\n        # 底部版权信息\\\\n        footer = ttk.Label(\\\\n            self.root,\\\\n            text=\\\\\\\"此软件完全免费，请勿倒卖！ by: 抖音@摄影师陈同学\\\\\\\",\\\\n            style=\\\\\\\"Modern.Secondary.TLabel\\\\\\\",\\\\n            anchor=\\\\\\\"center\\\\\\\"\\\\n        )\\\\n        footer.pack(fill=tk.X, pady=(0, 12))\\\\n    \\\\n    def _create_form_row(self, parent, label_text, row):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"创建表单行\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        ttk.Label(\\\\n            parent,\\\\n            text=label_text,\\\\n            style=\\\\\\\"Modern.Body.TLabel\\\\\\\"\\\\n        ).grid(row=row, column=0, sticky=\\\\\\\"e\\\\\\\", pady=(row > 0 and 12 or 0, 0))\\\\n    \\\\n    def _initialize_data(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"初始化数据\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 创建图像预览管理器\\\\n        self.preview_manager = ImagePreviewManager(self.preview_canvas, self.theme_manager)\\\\n        self.preview_manager.clear_preview()\\\\n        \\\\n        # 创建复制管理器\\\\n        self.copy_manager = CopyManager(\\\\n            self.info_box,\\\\n            self.status_var,\\\\n            self.progress_var,\\\\n            self.preview_manager\\\\n        )\\\\n        \\\\n        # 初始化驱动器列表\\\\n        self.refresh_sources(auto_pick=True)\\\\n    \\\\n    def _bind_events(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"绑定事件处理程序\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 主题切换\\\\n        self.theme_box.bind(\\\\\\\"<<ComboboxSelected>>\\\\\\\", self.on_theme_change)\\\\n        \\\\n        # 窗口关闭事件\\\\n        self.root.protocol(\\\\\\\"WM_DELETE_WINDOW\\\\\\\", self.on_window_close)\\\\n        \\\\n        # 分割窗拖动事件\\\\n        self.paned.bind(\\\\\\\"<ButtonRelease-1>\\\\\\\", self.remember_sash)\\\\n        self.root.bind(\\\\\\\"<Configure>\\\\\\\", lambda e: self.root.after(50, self.remember_sash))\\\\n        \\\\n        # 应用分割比例\\\\n        self.root.after(300, self.apply_sash_ratio_later)\\\\n        \\\\n        # 版权提示\\\\n        self.root.after(500, self.show_copyright)\\\\n    \\\\n    def refresh_sources(self, auto_pick=False):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"刷新源驱动器列表\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        all_drives = list_drives()\\\\n        removable = []; src_vals = []\\\\n        \\\\n        for d in all_drives:\\\\n            tname = drive_type_name(get_drive_type_code(d))\\\\n            if get_drive_type_code(d) == 2: removable.append(d)\\\\n            tag = \\\\\\\"(系统)\\\\\\\" if is_system_drive(d) else \\\\\\\"\\\\\\\"\\\\n            src_vals.append(f\\\\\\\"{d}  |  名称: {get_drive_label(d)}  |  类型: {tname}{tag}\\\\\\\")\\\\n        \\\\n        self.combo_src[\\\\\\\"values\\\\\\\"] = src_vals\\\\n        \\\\n        if auto_pick and removable:\\\\n            pick = removable[0]\\\\n            for i, s in enumerate(src_vals):\\\\n                if s.startswith(pick): \\\\n                    self.combo_src.current(i)\\\\n                    break\\\\n        \\\\n        log_init_if_empty(self.info_box, \\\\\\\"日志已启动\\\\\\\")\\\\n        \\\\n        if removable:\\\\n            log_add(self.info_box, f\\\\\\\"发现移动盘：{\\\\', \\\\'.join(removable)}\\\\\\\")\\\\n        else:\\\\n            log_add(self.info_box, \\\\\\\"未检测到移动盘\\\\\\\")\\\\n    \\\\n    def refresh_dests(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"刷新目标驱动器列表\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        vals = []\\\\n        for p in psutil.disk_partitions(all=False):\\\\n            letter = p.device.rstrip(\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\")\\\\n            if get_drive_type_code(letter) != 3: continue\\\\n            \\\\n            total, free = get_drive_usage_bytes(letter + \\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\")\\\\n            label = get_drive_label(letter)\\\\n            vals.append(f\\\\\\\"{letter} {label}（{bytes_to_human(free)} / {bytes_to_human(total)}）\\\\\\\")\\\\n        \\\\n        self.combo_dst[\\\\\\\"values\\\\\\\"] = vals\\\\n        log_add(self.info_box, \\\\\\\"已刷新目标固定磁盘列表\\\\\\\")\\\\n    \\\\n    def start_action(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"开始分类操作\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 检查源设备\\\\n        sv = self.combo_src.get()\\\\n        if not sv:\\\\n            messagebox.showwarning(\\\\\\\"提示\\\\\\\", \\\\\\\"请先选择素材盘。\\\\\\\")\\\\n            return\\\\n        \\\\n        src_drive = sv.split(\\\\\\\"|\\\\\\\", 1)[0].strip()\\\\n        \\\\n        # 检查源设备类型\\\\n        dtype = drive_type_name(get_drive_type_code(src_drive))\\\\n        \\\\n        # 系统盘警告\\\\n        if is_system_drive(src_drive):\\\\n            if not messagebox.askyesno(\\\\\\\"高风险确认\\\\\\\", f\\\\\\\"{src_drive} 是系统盘，不建议作为素材盘源。继续？\\\\\\\"):\\\\n                return\\\\n            if not messagebox.askyesno(\\\\\\\"二次确认\\\\\\\", \\\\\\\"再次确认从系统盘作为相机源复制？\\\\\\\"):\\\\n                return\\\\n        elif get_drive_type_code(src_drive) != 2:\\\\n            if not messagebox.askyesno(\\\\\\\"固定磁盘警告\\\\\\\", f\\\\\\\"{src_drive} 为固定盘，通常应选移动盘。继续？\\\\\\\"):\\\\n                return\\\\n        \\\\n        # 获取目标驱动器\\\\n        dst_letter = \\\\\\\"\\\\\\\"\\\\n        if self.combo_dst.get():\\\\n            dst_letter = self.combo_dst.get().split(\\\\\\\" \\\\\\\", 1)[0].strip().rstrip(\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\")\\\\n        \\\\n        # 更新按钮状态\\\\n        self.btn_start.config(state=tk.DISABLED)\\\\n        self.btn_stop.config(state=tk.NORMAL)\\\\n        \\\\n        # 启动复制线程\\\\n        copy_thread = self.copy_manager.start_copy(\\\\n            src_drive,\\\\n            dst_letter,\\\\n            self.cfg,\\\\n            self.root,\\\\n            self.combo_cat.get().strip(),\\\\n            extract_star=self.star_var.get()\\\\n        )\\\\n        \\\\n        # 监控线程完成\\\\n        def check_thread():\\\\n            if copy_thread.is_alive():\\\\n                self.root.after(500, check_thread)\\\\n            else:\\\\n                # 恢复按钮状态\\\\n                self.btn_start.config(state=tk.NORMAL)\\\\n                self.btn_stop.config(state=tk.DISABLED)\\\\n        \\\\n        self.root.after(500, check_thread)\\\\n    \\\\n    def stop_action(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"停止操作\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.copy_manager.stop_copy()\\\\n        self.status_var.set(\\\\\\\"正在停止...\\\\\\\")\\\\n    \\\\n    def on_theme_change(self, event=None):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"主题切换处理\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        sel = self.theme_box.get()\\\\n        key = \\\\\\\"light\\\\\\\" if sel == \\\\\\\"日间\\\\\\\" else \\\\\\\"dark\\\\\\\"\\\\n        \\\\n        self.cfg[\\\\\\\"theme\\\\\\\"] = key\\\\n        save_config(self.cfg)\\\\n        \\\\n        # 应用新主题\\\\n        self.theme_manager.apply_theme(\\\\n            self.root,\\\\n            key,\\\\n            widgets={\\\\n                \\\\\\\"text\\\\\\\": [self.info_box],\\\\n                \\\\\\\"canvas\\\\\\\": [self.preview_canvas]\\\\n            }\\\\n        )\\\\n    \\\\n    def remember_sash(self, event=None):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"记住分割窗口位置\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            self.root.update_idletasks()\\\\n            total_h = self.paned.winfo_height()\\\\n            pos = self.paned.sashpos(0)\\\\n            ratio = round(pos / max(total_h, 1), 4)\\\\n            \\\\n            self.cfg[\\\\\\\"sash_ratio\\\\\\\"] = max(0.15, min(0.85, ratio))\\\\n            save_config(self.cfg)\\\\n        except Exception:\\\\n            pass\\\\n    \\\\n    def apply_sash_ratio_later(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"延迟应用分割比例\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            self.root.update_idletasks()\\\\n            total_h = self.paned.winfo_height()\\\\n            \\\\n            if total_h <= 0:\\\\n                self.root.after(100, self.apply_sash_ratio_later)\\\\n                return\\\\n            \\\\n            pos = int(total_h * self.sash_ratio)\\\\n            self.paned.sashpos(0, pos)\\\\n        except Exception:\\\\n            pass\\\\n    \\\\n    def show_copyright(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"显示版权信息\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        log_add(self.info_box, \\\\\\\"=== 陈同学影像管理助手 v2.0.0 ===\\\\\\\")\\\\n        log_add(self.info_box, \\\\\\\"完全免费，禁止商用或倒卖！\\\\\\\")\\\\n        log_add(self.info_box, \\\\\\\"作者：抖音@摄影师陈同学\\\\\\\")\\\\n    \\\\n    def on_window_close(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"窗口关闭事件处理\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 保存窗口位置和大小\\\\n        pos = {\\\\n            \\\\\\\"x\\\\\\\": self.root.winfo_x(),\\\\n            \\\\\\\"y\\\\\\\": self.root.winfo_y()\\\\n        }\\\\n        \\\\n        size = {\\\\n            \\\\\\\"width\\\\\\\": self.root.winfo_width(),\\\\n            \\\\\\\"height\\\\\\\": self.root.winfo_height()\\\\n        }\\\\n        \\\\n        self.cfg[\\\\\\\"window_pos\\\\\\\"] = pos\\\\n        self.cfg[\\\\\\\"window_size\\\\\\\"] = size\\\\n        save_config(self.cfg)\\\\n        \\\\n        # 检查是否正在复制\\\\n        if hasattr(self, \\\\\\\"copy_manager\\\\\\\") and self.copy_manager.stop_event.is_set():\\\\n            if messagebox.askyesnocancel(\\\\\\\"确认退出\\\\\\\", \\\\\\\"正在进行复制操作，确定要退出吗？\\\\\\\"):\\\\n                self.copy_manager.stop_copy()\\\\n                self.root.destroy()\\\\n        else:\\\\n            self.root.destroy()\\\\n    \\\\n    def run(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"运行应用\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.root.mainloop()\\\\n\\\\n# ---------- 应用入口 ----------\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    # 设置中文字体支持\\\\n    if platform.system() == \\\\\\\"Windows\\\\\\\":\\\\n        os.environ[\\\\\\\"TCL_LIBRARY\\\\\\\"] = r\\\\\\\"C:\\\\\\\\Program Files\\\\\\\\Python38\\\\\\\\tcl\\\\\\\\tcl8.6\\\\\\\"\\\\n        os.environ[\\\\\\\"TK_LIBRARY\\\\\\\"] = r\\\\\\\"C:\\\\\\\\Program Files\\\\\\\\Python38\\\\\\\\tcl\\\\\\\\tk8.6\\\\\\\"\\\\n    \\\\n    # 创建并运行应用\\\\n    app = ModernPhotoSorterApp()\\\\n    app.run()\",\"originAcceptText\":\"# 陈同学影像管理助手 v2.0.0\\n# 现代UI版本 - 保留所有核心功能，增强视觉体验和交互性\\n\\nimport os, sys, json, time, shutil, platform, subprocess, re\\nimport tkinter as tk\\nfrom tkinter import ttk, messagebox, filedialog, simpledialog\\nfrom datetime import datetime\\nimport threading\\nfrom PIL import Image, ImageTk, ExifTags\\nimport psutil\\nimport exifread\\nfrom typing import Dict, List, Tuple, Optional, Set\\n\\nVERSION = \\\"v2.0.0\\\"\\nCONFIG_FILE = \\\"photo_sorter_config.json\\\"\\nCATEGORIES = [\\\"婚礼\\\", \\\"写真\\\", \\\"日常记录\\\", \\\"旅游记录\\\", \\\"商业活动拍摄\\\"]\\nTHEMES = [\\\"日间\\\", \\\"暗黑\\\"]\\n\\n# 支持的文件类型\\ndef is_raw_ext(e): return e.lower() in {\\\"cr2\\\", \\\"cr3\\\", \\\"nef\\\", \\\"nrw\\\", \\\"arw\\\", \\\"srf\\\", \\\"sr2\\\", \\\"raf\\\", \\\"rw2\\\", \\\"orf\\\", \\\"dng\\\", \\\"pef\\\", \\\"raw\\\"}\\ndef is_jpg_ext(e): return e.lower() in {\\\"jpg\\\", \\\"jpeg\\\", \\\"jpe\\\"}\\ndef is_video_ext(e): return e.lower() in {\\\"mp4\\\", \\\"mov\\\", \\\"avi\\\", \\\"mkv\\\", \\\"wmv\\\"}\\ndef is_image_ext(e): return is_raw_ext(e) or is_jpg_ext(e)\\n\\n# 提示音功能\\ntry:\\n    import winsound\\n    def beep_start(): winsound.MessageBeep(winsound.MB_ICONASTERISK)\\n    def beep_done():  winsound.MessageBeep(winsound.MB_ICONEXCLAMATION)\\nexcept Exception:\\n    def beep_start(): pass\\n    def beep_done():  pass\\n\\n# ---------- 工具函数 ----------\\ndef ts(): return datetime.now().strftime(\\\"%H:%M:%S\\\")\\n\\ndef bytes_to_human(n) -> str:\\n    try: n = int(n)\\n    except Exception: return \\\"N/A\\\"\\n    units = [\\\"B\\\", \\\"KB\\\", \\\"MB\\\", \\\"GB\\\", \\\"TB\\\", \\\"PB\\\", \\\"EB\\\"]\\n    i = 0; v = float(n)\\n    while v >= 1024.0 and i < len(units) - 1:\\n        v /= 1024.0; i += 1\\n    return f\\\"{v:.2f} {units[i]}\\\"\\n\\ndef get_drive_type_code(letter):\\n    import ctypes\\n    try: return ctypes.windll.kernel32.GetDriveTypeW(letter + \\\"\\\\\\\\\\\")\\n    except Exception: return 0\\n\\ndef drive_type_name(code): return {2:\\\"移动\\\",3:\\\"固定\\\",4:\\\"网络\\\",5:\\\"光驱\\\",6:\\\"RAM\\\"}.get(code,\\\"未知\\\")\\ndef is_system_drive(letter): return letter.upper().startswith(os.environ.get(\\\"SystemDrive\\\",\\\"C:\\\").upper())\\ndef list_drives(): return [p.device for p in psutil.disk_partitions(all=True) if os.path.exists(p.mountpoint)]\\n\\ndef get_drive_label(letter):\\n    import ctypes\\n    try:\\n        vn=ctypes.create_unicode_buffer(1024); fs=ctypes.create_unicode_buffer(1024)\\n        sn=ctypes.c_ulong(); mcl=ctypes.c_ulong(); fl=ctypes.c_ulong()\\n        ctypes.windll.kernel32.GetVolumeInformationW(letter+\\\"\\\\\\\\\\\",vn,1024,ctypes.byref(sn),ctypes.byref(mcl),ctypes.byref(fl),fs,1024)\\n        name=vn.value.strip()\\n    except Exception: name=\\\"\\\"\\n    if not name and get_drive_type_code(letter)==2: return \\\"U盘\\\"\\n    return name or \\\"(无名称)\\\"\\n\\ndef get_drive_usage_bytes(root):\\n    u=psutil.disk_usage(root); return u.total,u.free\\n\\ndef load_config():\\n    if os.path.exists(CONFIG_FILE):\\n        with open(CONFIG_FILE,\\\"r\\\",encoding=\\\"utf-8\\\") as f:\\n            cfg = json.load(f)\\n            # 确保配置项存在\\n            if \\\"theme\\\" not in cfg: cfg[\\\"theme\\\"] = \\\"light\\\"\\n            if \\\"sash_ratio\\\" not in cfg: cfg[\\\"sash_ratio\\\"] = 0.55\\n            if \\\"window_pos\\\" not in cfg: cfg[\\\"window_pos\\\"] = {\\\"x\\\": 100, \\\"y\\\": 100}\\n            if \\\"window_size\\\" not in cfg: cfg[\\\"window_size\\\"] = {\\\"width\\\": 1000, \\\"height\\\": 720}\\n            return cfg\\n    return {\\\"last_target_root\\\": \\\"\\\", \\\"theme\\\": \\\"light\\\", \\\"sash_ratio\\\": 0.55, \\\"window_pos\\\": {\\\"x\\\": 100, \\\"y\\\": 100}, \\\"window_size\\\": {\\\"width\\\": 1000, \\\"height\\\": 720}}\\n\\ndef save_config(cfg):\\n    with open(CONFIG_FILE,\\\"w\\\",encoding=\\\"utf-8\\\") as f: json.dump(cfg,f,ensure_ascii=False,indent=2)\\n\\n# ---------- EXIF / XMP处理 ----------\\ndef _parse_exif_str(s):\\n    s=s.strip()\\n    if len(s)>=19 and s[4]==\\\":\\\" and s[7]==\\\":\\\" and s[10]==\\\" \\\" and s[13]==\\\":\\\" and s[16]==\\\":\\\" :\\n        return datetime.strptime(s[:19],\\\"%Y:%m:%d %H:%M:%S\\\")\\n    return None\\n\\ndef _exif_dt_from_jpg(p):\\n    try:\\n        im=Image.open(p); exif=im._getexif()\\n        if not exif: return None\\n        tag={ExifTags.TAGS.get(k,k):v for k,v in exif.items()}\\n        for k in(\\\"DateTimeOriginal\\\",\\\"DateTimeDigitized\\\",\\\"DateTime\\\"):\\n            v=tag.get(k)\\n            if isinstance(v,str):\\n                dt=_parse_exif_str(v)\\n                if dt: return dt\\n    except Exception: pass\\n    return None\\n\\ndef _exif_dt_from_any(p):\\n    try:\\n        with open(p,\\\"rb\\\") as f: tags=exifread.process_file(f,stop_tag=\\\"EXIF DateTimeOriginal\\\",details=False)\\n        for k in(\\\"EXIF DateTimeOriginal\\\",\\\"Image DateTime\\\",\\\"EXIF DateTimeDigitized\\\"):\\n            if k in tags:\\n                dt=_parse_exif_str(str(tags[k]))\\n                if dt: return dt\\n    except Exception: pass\\n    return None\\n\\ndef get_capture_dt(p):\\n    ext=p.rsplit(\\\".\\\",1)[-1].lower() if \\\".\\\" in p else \\\"\\\"\\n    if is_jpg_ext(ext): dt=_exif_dt_from_jpg(p) or _exif_dt_from_any(p)\\n    elif is_raw_ext(ext): dt=_exif_dt_from_any(p)\\n    else: dt=None\\n    if dt: return dt\\n    try: return datetime.fromtimestamp(os.path.getmtime(p))\\n    except Exception: return datetime.now()\\n\\n# ---------- 星标检测 ----------\\n_XMP_RATING_PATTERNS = [\\n    re.compile(rb\\\"<xmp:Rating>\\\\s*(-?\\\\d+)\\\\s*</xmp:Rating>\\\", re.I),\\n    re.compile(rb\\\"Rating=\\\\\\\"\\\\s*(-?\\\\d+)\\\\s*\\\\\\\"\\\", re.I),\\n]\\n\\ndef _find_rating_in_bytes(b: bytes) -> int:\\n    for pat in _XMP_RATING_PATTERNS:\\n        m = pat.search(b)\\n        if m:\\n            try: return int(m.group(1))\\n            except Exception: pass\\n    return 0\\n\\ndef is_starred_file(path: str) -> bool:\\n    stem, _ = os.path.splitext(path)\\n    sidecar = stem + \\\".xmp\\\"\\n    try:\\n        if os.path.isfile(sidecar):\\n            with open(sidecar, \\\"rb\\\") as f:\\n                rating = _find_rating_in_bytes(f.read(512*1024))\\n                return rating >= 1\\n    except Exception:\\n        pass\\n    try:\\n        with open(path, \\\"rb\\\") as f:\\n            rating = _find_rating_in_bytes(f.read(1024*1024))\\n            return rating >= 1\\n    except Exception:\\n        return False\\n\\n# ---------- 其他工具 ----------\\ndef unique_path(d, f):\\n    n, e = os.path.splitext(f); c = os.path.join(d, f); i = 1\\n    while os.path.exists(c):\\n        c = os.path.join(d, f\\\"{n}({i}){e}\\\"); i += 1\\n    return c\\n\\ndef _open_folder(p):\\n    try:\\n        if platform.system() == \\\"Windows\\\": os.startfile(p)\\n        elif platform.system() == \\\"Darwin\\\": subprocess.Popen([\\\"open\\\", p])\\n        else: subprocess.Popen([\\\"xdg-open\\\", p])\\n    except Exception:\\n        pass\\n\\n# ---------- 日志处理 ----------\\ndef log_init_if_empty(text_widget, line):\\n    if float(text_widget.index(\\\"end-1c\\\")) == 1.0:\\n        text_widget.configure(state=\\\"normal\\\")\\n        text_widget.insert(\\\"end\\\", f\\\"[{ts()}] {line}\\\\n\\\")\\n        text_widget.configure(state=\\\"disabled\\\")\\n\\ndef log_add(text_widget, line):\\n    text_widget.configure(state=\\\"normal\\\")\\n    text_widget.insert(\\\"end\\\", f\\\"[{ts()}] {line}\\\\n\\\")\\n    text_widget.see(\\\"end\\\")\\n    text_widget.configure(state=\\\"disabled\\\")\\n\\n# ---------- 扫描/计划 ----------\\ndef preflight_scan(src_root):\\n    counts = {\\\"RAW\\\": 0, \\\"JPG\\\": 0, \\\"VIDEO\\\": 0};\\n    sizes = {\\\"RAW\\\": 0, \\\"JPG\\\": 0, \\\"VIDEO\\\": 0}\\n    files = {\\\"RAW\\\": [], \\\"JPG\\\": [], \\\"VIDEO\\\": []}\\n    \\n    for root, _, fs in os.walk(src_root):\\n        for f in fs:\\n            ext = f.rsplit('.', 1)[-1].lower() if '.' in f else \\\"\\\"\\n            full = os.path.join(root, f)\\n            try: sz = os.path.getsize(full)\\n            except Exception: sz = 0\\n            \\n            if is_raw_ext(ext): \\n                counts[\\\"RAW\\\"] += 1; sizes[\\\"RAW\\\"] += sz; files[\\\"RAW\\\"].append(full)\\n            elif is_jpg_ext(ext): \\n                counts[\\\"JPG\\\"] += 1; sizes[\\\"JPG\\\"] += sz; files[\\\"JPG\\\"].append(full)\\n            elif is_video_ext(ext): \\n                counts[\\\"VIDEO\\\"] += 1; sizes[\\\"VIDEO\\\"] += sz; files[\\\"VIDEO\\\"].append(full)\\n    \\n    return counts, sizes, files\\n\\ndef build_seq_plan(photo_files, mmdd_str):\\n    entries = []\\n    for p in photo_files:\\n        ext = p.rsplit(\\\".\\\", 1)[-1].lower() if \\\".\\\" in p else \\\"\\\"\\n        stem = os.path.splitext(os.path.basename(p))[0]\\n        dt = get_capture_dt(p)\\n        entries.append({\\\"path\\\": p, \\\"ext\\\": ext, \\\"stem\\\": stem, \\\"dt\\\": dt})\\n    \\n    entries.sort(key=lambda x: (x[\\\"dt\\\"], x[\\\"stem\\\"], x[\\\"ext\\\"]))\\n    stem_to_idx = {}; seq = 0; plan = []\\n    \\n    for e in entries:\\n        if e[\\\"stem\\\"] in stem_to_idx: idx = stem_to_idx[e[\\\"stem\\\"]]\\n        else: seq += 1; idx = seq; stem_to_idx[e[\\\"stem\\\"]] = idx\\n        plan.append((e[\\\"path\\\"], f\\\"{mmdd_str}-{idx:04d}\\\", e[\\\"ext\\\"]))\\n    \\n    return plan\\n\\n# ---------- 主题管理 ----------\\nclass ThemeManager:\\n    \\\"\\\"\\\"主题管理器 - 提供现代UI的主题支持\\\"\\\"\\\"\\n    \\n    THEMES = {\\n        \\\"light\\\": {\\n            \\\"BG\\\": \\\"#F8FAFC\\\",\\n            \\\"CARD\\\": \\\"#FFFFFF\\\",\\n            \\\"TEXT\\\": \\\"#1E293B\\\",\\n            \\\"TEXT_SECONDARY\\\": \\\"#64748B\\\",\\n            \\\"BORDER\\\": \\\"#E2E8F0\\\",\\n            \\\"PRIMARY\\\": \\\"#3B82F6\\\",  # 蓝色主题\\n            \\\"PRIMARY_HOVER\\\": \\\"#2563EB\\\",\\n            \\\"SUCCESS\\\": \\\"#10B981\\\",  # 绿色\\n            \\\"WARNING\\\": \\\"#F59E0B\\\",  # 黄色\\n            \\\"DANGER\\\": \\\"#EF4444\\\",   # 红色\\n            \\\"INPUT_BG\\\": \\\"#FFFFFF\\\",\\n            \\\"INPUT_FG\\\": \\\"#1E293B\\\",\\n            \\\"PROGRESS_BG\\\": \\\"#E2E8F0\\\",\\n            \\\"LOG_BG\\\": \\\"#F1F5F9\\\",\\n            \\\"SHADOW\\\": \\\"0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)\\\"\\n        },\\n        \\\"dark\\\": {\\n            \\\"BG\\\": \\\"#0F172A\\\",\\n            \\\"CARD\\\": \\\"#1E293B\\\",\\n            \\\"TEXT\\\": \\\"#F8FAFC\\\",\\n            \\\"TEXT_SECONDARY\\\": \\\"#94A3B8\\\",\\n            \\\"BORDER\\\": \\\"#334155\\\",\\n            \\\"PRIMARY\\\": \\\"#3B82F6\\\",\\n            \\\"PRIMARY_HOVER\\\": \\\"#60A5FA\\\",\\n            \\\"SUCCESS\\\": \\\"#10B981\\\",\\n            \\\"WARNING\\\": \\\"#F59E0B\\\",\\n            \\\"DANGER\\\": \\\"#EF4444\\\",\\n            \\\"INPUT_BG\\\": \\\"#334155\\\",\\n            \\\"INPUT_FG\\\": \\\"#F8FAFC\\\",\\n            \\\"PROGRESS_BG\\\": \\\"#334155\\\",\\n            \\\"LOG_BG\\\": \\\"#0F172A\\\",\\n            \\\"SHADOW\\\": \\\"0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2)\\\"\\n        }\\n    }\\n    \\n    @staticmethod\\n    def apply_theme(root, theme_key, widgets=None):\\n        \\\"\\\"\\\"应用主题到根窗口和指定控件\\\"\\\"\\\"\\n        style = ttk.Style()\\n        try: style.theme_use(\\\"clam\\\")\\n        except Exception: pass\\n        \\n        P = ThemeManager.THEMES[\\\"dark\\\" if theme_key == \\\"dark\\\" else \\\"light\\\"]\\n        \\n        # 配置根窗口\\n        root.configure(bg=P[\\\"BG\\\"])\\n        \\n        # 配置ttk样式\\n        # 标题标签\\n        style.configure(\\n            \\\"Modern.Title.TLabel\\\",\\n            background=P[\\\"BG\\\"],\\n            foreground=P[\\\"TEXT\\\"],\\n            font=(\\\"Microsoft YaHei UI\\\", 20, \\\"bold\\\"),\\n            padding=(0, 10)\\n        )\\n        \\n        # 副标题标签\\n        style.configure(\\n            \\\"Modern.Subtitle.TLabel\\\",\\n            background=P[\\\"BG\\\"],\\n            foreground=P[\\\"TEXT\\\"],\\n            font=(\\\"Microsoft YaHei UI\\\", 14, \\\"bold\\\"),\\n            padding=(0, 8)\\n        )\\n        \\n        # 正文标签\\n        style.configure(\\n            \\\"Modern.Body.TLabel\\\",\\n            background=P[\\\"BG\\\"],\\n            foreground=P[\\\"TEXT\\\"],\\n            font=(\\\"Microsoft YaHei UI\\\", 12),\\n            padding=(0, 4)\\n        )\\n        \\n        # 次要文本标签\\n        style.configure(\\n            \\\"Modern.Secondary.TLabel\\\",\\n            background=P[\\\"BG\\\"],\\n            foreground=P[\\\"TEXT_SECONDARY\\\"],\\n            font=(\\\"Microsoft YaHei UI\\\", 11),\\n            padding=(0, 4)\\n        )\\n        \\n        # 框架样式\\n        style.configure(\\n            \\\"Modern.Frame.TFrame\\\",\\n            background=P[\\\"BG\\\"],\\n            borderwidth=0\\n        )\\n        \\n        # 卡片样式\\n        style.configure(\\n            \\\"Modern.Card.TFrame\\\",\\n            background=P[\\\"CARD\\\"],\\n            borderwidth=1,\\n            relief=\\\"flat\\\",\\n            bordercolor=P[\\\"BORDER\\\"]\\n        )\\n        \\n        # 主按钮\\n        style.configure(\\n            \\\"Modern.Primary.TButton\\\",\\n            background=P[\\\"PRIMARY\\\"],\\n            foreground=\\\"#FFFFFF\\\",\\n            font=(\\\"Microsoft YaHei UI\\\", 12, \\\"bold\\\"),\\n            padding=(12, 6),\\n            borderwidth=0,\\n            focuscolor=\\\"none\\\"\\n        )\\n        style.map(\\n            \\\"Modern.Primary.TButton\\\",\\n            background=[(\\\"active\\\", P[\\\"PRIMARY_HOVER\\\"])],\\n            relief=[(\\\"pressed\\\", \\\"flat\\\")]\\n        )\\n        \\n        # 次要按钮\\n        style.configure(\\n            \\\"Modern.Secondary.TButton\\\",\\n            background=P[\\\"BORDER\\\"],\\n            foreground=P[\\\"TEXT\\\"],\\n            font=(\\\"Microsoft YaHei UI\\\", 12),\\n            padding=(12, 6),\\n            borderwidth=0\\n        )\\n        style.map(\\n            \\\"Modern.Secondary.TButton\\\",\\n            background=[(\\\"active\\\", P[\\\"CARD\\\"])],\\n            relief=[(\\\"pressed\\\", \\\"flat\\\")]\\n        )\\n        \\n        # 进度条\\n        style.configure(\\n            \\\"Modern.Horizontal.TProgressbar\\\",\\n            troughcolor=P[\\\"PROGRESS_BG\\\"],\\n            background=P[\\\"PRIMARY\\\"],\\n            bordercolor=P[\\\"PROGRESS_BG\\\"],\\n            lightcolor=P[\\\"PRIMARY\\\"],\\n            darkcolor=P[\\\"PRIMARY\\\"],\\n            borderwidth=0\\n        )\\n        \\n        # 下拉框\\n        style.configure(\\n            \\\"Modern.TCombobox\\\",\\n            fieldbackground=P[\\\"INPUT_BG\\\"],\\n            background=P[\\\"INPUT_BG\\\"],\\n            foreground=P[\\\"INPUT_FG\\\"],\\n            bordercolor=P[\\\"BORDER\\\"],\\n            arrowcolor=P[\\\"TEXT\\\"],\\n            font=(\\\"Microsoft YaHei UI\\\", 11),\\n            padding=(6, 4)\\n        )\\n        style.map(\\n            \\\"Modern.TCombobox\\\",\\n            fieldbackground=[(\\\"readonly\\\", P[\\\"INPUT_BG\\\"])],\\n            foreground=[(\\\"readonly\\\", P[\\\"INPUT_FG\\\"])],\\n            background=[(\\\"readonly\\\", P[\\\"INPUT_BG\\\"])],\\n            arrowcolor=[(\\\"active\\\", P[\\\"PRIMARY\\\"])]\\n        )\\n        \\n        # 复选框\\n        style.configure(\\n            \\\"Modern.TCheckbutton\\\",\\n            background=P[\\\"BG\\\"],\\n            foreground=P[\\\"TEXT\\\"],\\n            font=(\\\"Microsoft YaHei UI\\\", 11)\\n        )\\n        style.map(\\n            \\\"Modern.TCheckbutton\\\",\\n            background=[(\\\"active\\\", P[\\\"BG\\\"])]\\n        )\\n        \\n        # 配置自定义控件\\n        if widgets:\\n            for widget_type, widget_list in widgets.items():\\n                if widget_type == \\\"text\\\":\\n                    for text_widget in widget_list:\\n                        text_widget.configure(\\n                            bg=P[\\\"LOG_BG\\\"],\\n                            fg=P[\\\"TEXT\\\"],\\n                            insertbackground=P[\\\"TEXT\\\"],\\n                            font=(\\\"Microsoft YaHei UI\\\", 10)\\n                        )\\n                elif widget_type == \\\"canvas\\\":\\n                    for canvas in widget_list:\\n                        canvas.configure(bg=P[\\\"CARD\\\"])\\n\\n# ---------- 图像预览管理器 ----------\\nclass ImagePreviewManager:\\n    \\\"\\\"\\\"图像预览管理器 - 负责处理和显示图像预览\\\"\\\"\\\"\\n    \\n    def __init__(self, canvas, theme_manager):\\n        self.canvas = canvas\\n        self.theme_manager = theme_manager\\n        self.current_image = None\\n        self.current_thumb = None\\n        self.current_info = None\\n        \\n        # 绑定画布调整事件\\n        self.canvas.bind(\\\"<Configure>\\\", self._on_canvas_resize)\\n    \\n    def _on_canvas_resize(self, event):\\n        \\\"\\\"\\\"画布大小改变时重新显示预览\\\"\\\"\\\"\\n        if self.current_image:\\n            self.show_preview(self.current_image, self.current_info)\\n    \\n    def show_preview(self, image_path, info=None):\\n        \\\"\\\"\\\"显示图像预览\\\"\\\"\\\"\\n        self.current_image = image_path\\n        self.current_info = info\\n        \\n        try:\\n            # 清空画布\\n            self.canvas.delete(\\\"all\\\")\\n            \\n            # 检查文件是否存在且为图像\\n            if not os.path.exists(image_path) or not is_image_ext(image_path.split(\\\".\\\")[-1]):\\n                self._show_placeholder(\\\"不支持预览此文件类型\\\")\\n                return\\n            \\n            # 尝试打开图像\\n            with Image.open(image_path) as img:\\n                # 获取画布尺寸\\n                canvas_width = self.canvas.winfo_width()\\n                canvas_height = self.canvas.winfo_height()\\n                \\n                if canvas_width <= 10 or canvas_height <= 10:  # 画布尚未渲染\\n                    return\\n                \\n                # 计算缩放比例\\n                max_size = (canvas_width - 40, canvas_height - 80)  # 留出边距\\n                img.thumbnail(max_size, Image.Resampling.LANCZOS)\\n                \\n                # 创建缩略图\\n                self.current_thumb = ImageTk.PhotoImage(img)\\n                \\n                # 显示图像（居中）\\n                x = (canvas_width - self.current_thumb.width()) // 2\\n                y = (canvas_height - self.current_thumb.height() - 40) // 2  # 留出底部信息空间\\n                self.canvas.create_image(x, y, anchor=tk.CENTER, image=self.current_thumb)\\n                \\n                # 绘制文件名\\n                filename = os.path.basename(image_path)\\n                self.canvas.create_text(\\n                    canvas_width // 2, \\n                    canvas_height - 50, \\n                    text=filename, \\n                    fill=self.theme_manager.THEMES[\\\"light\\\"][\\\"TEXT\\\"],  # 简化处理，实际应根据当前主题获取\\n                    font=(\\\"Microsoft YaHei UI\\\", 10, \\\"bold\\\"),\\n                    width=canvas_width - 40\\n                )\\n                \\n                # 绘制文件信息\\n                if info:\\n                    self.canvas.create_text(\\n                        canvas_width // 2, \\n                        canvas_height - 25, \\n                        text=info, \\n                        fill=self.theme_manager.THEMES[\\\"light\\\"][\\\"TEXT_SECONDARY\\\"],\\n                        font=(\\\"Microsoft YaHei UI\\\", 9),\\n                        width=canvas_width - 40\\n                    )\\n        \\n        except Exception as e:\\n            self._show_placeholder(\\\"无法预览图像\\\")\\n    \\n    def _show_placeholder(self, text):\\n        \\\"\\\"\\\"显示占位符\\\"\\\"\\\"\\n        self.canvas.delete(\\\"all\\\")\\n        canvas_width = self.canvas.winfo_width()\\n        canvas_height = self.canvas.winfo_height()\\n        \\n        # 绘制占位符图标（简化为文本）\\n        self.canvas.create_text(\\n            canvas_width // 2, \\n            canvas_height // 2, \\n            text=\\\"📷\\\", \\n            font=(\\\"Arial\\\", 48)\\n        )\\n        \\n        # 绘制提示文本\\n        self.canvas.create_text(\\n            canvas_width // 2, \\n            canvas_height // 2 + 40, \\n            text=text, \\n            fill=self.theme_manager.THEMES[\\\"light\\\"][\\\"TEXT_SECONDARY\\\"],\\n            font=(\\\"Microsoft YaHei UI\\\", 11)\\n        )\\n    \\n    def clear_preview(self):\\n        \\\"\\\"\\\"清除预览\\\"\\\"\\\"\\n        self.canvas.delete(\\\"all\\\")\\n        self.current_image = None\\n        self.current_thumb = None\\n        self.current_info = None\\n        self._show_placeholder(\\\"等待预览\\\")\\n\\n# ---------- 复制管理器 ----------\\nclass CopyManager:\\n    \\\"\\\"\\\"复制管理器 - 处理文件复制逻辑，支持进度报告和预览更新\\\"\\\"\\\"\\n    \\n    def __init__(self, log_widget, status_var, progress_var, preview_manager=None):\\n        self.log_widget = log_widget\\n        self.status_var = status_var\\n        self.progress_var = progress_var\\n        self.preview_manager = preview_manager\\n        self.stop_event = threading.Event()\\n        self.created_files = []\\n    \\n    def start_copy(self, src_drive, dst_letter, cfg, root, category, extract_star=False):\\n        \\\"\\\"\\\"开始复制过程\\\"\\\"\\\"\\n        # 重置状态\\n        self.stop_event.clear()\\n        self.created_files = []\\n        \\n        # 创建并启动线程\\n        copy_thread = threading.Thread(\\n            target=self._copy_thread,\\n            args=(src_drive, dst_letter, cfg, root, category, extract_star)\\n        )\\n        copy_thread.daemon = True\\n        copy_thread.start()\\n        \\n        return copy_thread\\n    \\n    def stop_copy(self):\\n        \\\"\\\"\\\"停止复制过程\\\"\\\"\\\"\\n        self.stop_event.set()\\n    \\n    def _copy_thread(self, src_drive, dst_letter, cfg, root, category, extract_star):\\n        \\\"\\\"\\\"复制线程函数\\\"\\\"\\\"\\n        try:\\n            # 1. 收集信息和创建目录\\n            log_add(self.log_widget, f\\\"素材盘：{src_drive}（{get_drive_label(src_drive)} | {drive_type_name(get_drive_type_code(src_drive))}）\\\")\\n            \\n            # 2. 获取拍摄名称\\n            shoot_name = None\\n            def ask_name():\\n                nonlocal shoot_name\\n                shoot_name = simpledialog.askstring(\\\"本次拍摄名称\\\", \\\"输入拍摄地点或主题（可中文）：\\\", parent=root)\\n            root.after(0, ask_name)\\n            \\n            # 等待用户输入\\n            while shoot_name is None and not self.stop_event.is_set():\\n                time.sleep(0.1)\\n            \\n            if self.stop_event.is_set() or not shoot_name:\\n                root.after(0, lambda: log_add(self.log_widget, \\\"用户取消操作\\\"))\\n                return\\n            \\n            # 3. 预检文件\\n            root.after(0, lambda: log_add(self.log_widget, \\\"开始预检源文件…\\\"))\\n            counts, sizes, files = preflight_scan(src_drive)\\n            total_files = counts[\\\"RAW\\\"] + counts[\\\"JPG\\\"] + counts[\\\"VIDEO\\\"]\\n            total_size = sizes[\\\"RAW\\\"] + sizes[\\\"JPG\\\"] + sizes[\\\"VIDEO\\\"]\\n            \\n            root.after(0, lambda: log_add(self.log_widget, \\n                f\\\"预检完成 RAW:{counts['RAW']} JPG:{counts['JPG']} VIDEO:{counts['VIDEO']} 合计:{total_files} | 体积 {bytes_to_human(total_size)}\\\"))\\n            \\n            # 4. 确认对话框\\n            confirm = False\\n            def show_confirm():\\n                nonlocal confirm\\n                confirm = messagebox.askyesno(\\n                    \\\"确认复制\\\",\\n                    f\\\"预检完成：\\\\n\\\"\\n                f\\\"RAW：{counts['RAW']}（{bytes_to_human(sizes['RAW'])}）\\\\n\\\"\\n                f\\\"JPG：{counts['JPG']}（{bytes_to_human(sizes['JPG'])}）\\\\n\\\"\\n                f\\\"VIDEO：{counts['VIDEO']}（{bytes_to_human(sizes['VIDEO'])}）\\\\n\\\"\\n                f\\\"合计：{total_files}（{bytes_to_human(total_size)}）\\\\n\\\\n\\\"\\n                f\\\"将复制到：年/拍摄类型/MM月/MM.DD_拍摄名/（RAW,JPG,VIDEO，及可选已星标照片）\\\\n\\\"\\n                f\\\"照片重命名：MMDD-0001 起；视频保留原名。\\\"\\n                )\\n            root.after(0, show_confirm)\\n            \\n            # 等待用户确认\\n            while confirm is None and not self.stop_event.is_set():\\n                time.sleep(0.1)\\n            \\n            if self.stop_event.is_set() or not confirm:\\n                root.after(0, lambda: log_add(self.log_widget, \\\"用户取消复制\\\"))\\n                return\\n            \\n            # 5. 确定目标目录\\n            if dst_letter:\\n                target_root = dst_letter + \\\"\\\\\\\\\\\"\\n            else:\\n                target_root = cfg.get(\\\"last_target_root\\\", \\\"\\\")\\n                if not os.path.exists(target_root):\\n                    def ask_dir():\\n                        nonlocal target_root\\n                        target_root = filedialog.askdirectory(title=\\\"选择目标硬盘文件夹（建议为外置硬盘根目录）\\\")\\n                    root.after(0, ask_dir)\\n                    \\n                    while target_root is None and not self.stop_event.is_set():\\n                        time.sleep(0.1)\\n                    \\n                    if self.stop_event.is_set() or not target_root:\\n                        root.after(0, lambda: log_add(self.log_widget, \\\"用户取消操作\\\"))\\n                        return\\n            \\n            cfg[\\\"last_target_root\\\"] = target_root\\n            save_config(cfg)\\n            \\n            # 检查目标盘与源盘是否相同\\n            if os.path.splitdrive(target_root)[0].upper() == os.path.splitdrive(src_drive)[0].upper():\\n                same_drive = False\\n                def ask_same_drive():\\n                    nonlocal same_drive\\n                    same_drive = messagebox.askyesno(\\\"风险提示\\\", \\\"目标盘与素材盘相同盘符，建议不同物理盘。继续？\\\")\\n                root.after(0, ask_same_drive)\\n                \\n                while same_drive is None and not self.stop_event.is_set():\\n                    time.sleep(0.1)\\n                \\n                if self.stop_event.is_set() or not same_drive:\\n                    root.after(0, lambda: log_add(self.log_widget, \\\"用户取消操作\\\"))\\n                    return\\n            \\n            # 6. 创建目标目录结构\\n            today = datetime.now()\\n            year_dir = os.path.join(target_root, str(today.year))\\n            cat_dir = os.path.join(year_dir, category)\\n            month_dir = os.path.join(cat_dir, f\\\"{today.month:02d}月\\\")\\n            day_folder = f\\\"{today.month:02d}.{today.day:02d}_{shoot_name}\\\"\\n            target_dir = os.path.join(month_dir, day_folder)\\n            \\n            os.makedirs(target_dir, exist_ok=True)\\n            root.after(0, lambda: log_add(self.log_widget, f\\\"目标目录：{target_dir}\\\"))\\n            \\n            # 7. 检查目标空间\\n            try:\\n                _, dst_free = get_drive_usage_bytes(os.path.splitdrive(target_root)[0] + \\\"\\\\\\\\\\\")\\n                if dst_free < total_size:\\n                    root.after(0, lambda: log_add(self.log_widget, \\n                        f\\\"目标剩余 {bytes_to_human(dst_free)} < 需要 {bytes_to_human(total_size)}\\\"))\\n                    \\n                    space_ok = False\\n                    def ask_space():\\n                        nonlocal space_ok\\n                        space_ok = messagebox.askretrycancel(\\n                            \\\"空间不足\\\",\\n                            f\\\"目标剩余 {bytes_to_human(dst_free)}，预计需要 {bytes_to_human(total_size)}。清理后重试。\\\"\\n                        )\\n                    root.after(0, ask_space)\\n                    \\n                    while space_ok is None and not self.stop_event.is_set():\\n                        time.sleep(0.1)\\n                    \\n                    if self.stop_event.is_set() or not space_ok:\\n                        root.after(0, lambda: log_add(self.log_widget, \\\"空间不足，取消操作\\\"))\\n                        return\\n            except Exception:\\n                pass\\n            \\n            # 8. 准备复制\\n            log_file = os.path.join(target_dir, \\\"copy_log.txt\\\")\\n            mmdd_str = f\\\"{today.month:02d}{today.day:02d}\\\"\\n            \\n            # 初始化进度条\\n            root.after(0, lambda: self.progress_var.set(0))\\n            root.after(0, lambda: self.status_var.set(\\\"准备复制…\\\"))\\n            \\n            # 开始提示音\\n            beep_start()\\n            root.after(0, lambda: log_add(self.log_widget, \\\"开始复制…\\\"))\\n            \\n            # 9. 执行复制\\n            self._copy_files(files, target_dir, log_file, mmdd_str, total_size, extract_star, root)\\n            \\n            # 10. 完成操作\\n            if not self.stop_event.is_set():\\n                root.after(0, lambda: log_add(self.log_widget, f\\\"复制完成 共 {len(self.created_files)} 个目标文件\\\"))\\n                root.after(0, lambda: self.status_var.set(\\\"复制完成\\\"))\\n                \\n                # 创建清单文件\\n                ts2 = datetime.now().strftime(\\\"%Y%m%d_%H%M%S\\\")\\n                manifest = {\\n                    \\\"version\\\": VERSION,\\n                    \\\"created_at\\\": ts2,\\n                    \\\"source_drive\\\": src_drive,\\n                    \\\"target_dir\\\": target_dir,\\n                    \\\"files\\\": self.created_files\\n                }\\n                \\n                try:\\n                    with open(os.path.join(target_dir, f\\\"import_manifest_{ts2}.json\\\"), \\\"w\\\", encoding=\\\"utf-8\\\") as f:\\n                        json.dump(manifest, f, ensure_ascii=False, indent=2)\\n                except Exception:\\n                    pass\\n                \\n                # 完成提示音\\n                beep_done()\\n                \\n                # 显示完成窗口\\n                root.after(0, lambda: self._show_finish_window(root, target_dir))\\n            else:\\n                root.after(0, lambda: self.status_var.set(\\\"已停止\\\"))\\n                root.after(0, lambda: log_add(self.log_widget, \\\"复制已停止\\\"))\\n        \\n        except Exception as e:\\n            root.after(0, lambda: log_add(self.log_widget, f\\\"错误：{str(e)}\\\"))\\n            root.after(0, lambda: self.status_var.set(\\\"错误\\\"))\\n    \\n    def _copy_files(self, src_files, dst, log_file, mmdd_str, total_bytes, extract_star, root):\\n        \\\"\\\"\\\"执行文件复制，显示进度和预览\\\"\\\"\\\"\\n        created = []; done = set()\\n        \\n        # 读取已完成的文件\\n        if os.path.exists(log_file):\\n            try:\\n                with open(log_file, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n                    for line in f:\\n                        if line.startswith(\\\"完成: \\\"):\\n                            done.add(line.split(\\\"完成: \\\", 1)[1].split(\\\" -> \\\", 1)[0].strip())\\n            except Exception:\\n                pass\\n        \\n        # 准备目标目录\\n        photo_files = src_files[\\\"RAW\\\"] + src_files[\\\"JPG\\\"]\\n        video_files = src_files[\\\"VIDEO\\\"]\\n        \\n        raw_dir = os.path.join(dst, \\\"RAW\\\")\\n        jpg_dir = os.path.join(dst, \\\"JPG\\\")\\n        vid_dir = os.path.join(dst, \\\"VIDEO\\\")\\n        \\n        os.makedirs(raw_dir, exist_ok=True)\\n        os.makedirs(jpg_dir, exist_ok=True)\\n        os.makedirs(vid_dir, exist_ok=True)\\n        \\n        # 准备星标目录\\n        star_root = os.path.join(dst, \\\"已星标照片\\\")\\n        star_jpg = os.path.join(star_root, \\\"已星标JPG\\\")\\n        star_raw = os.path.join(star_root, \\\"已星标RAW\\\")\\n        \\n        if extract_star:\\n            os.makedirs(star_jpg, exist_ok=True)\\n            os.makedirs(star_raw, exist_ok=True)\\n        \\n        # 构建照片重命名计划\\n        plan = build_seq_plan(photo_files, mmdd_str)\\n        final_map = {}\\n        \\n        bytes_done = 0\\n        t0 = time.time()\\n        last_preview_update = 0\\n        \\n        # 更新状态函数\\n        def update_status(label_text):\\n            elapsed = max(time.time() - t0, 1e-6)\\n            speed_mb = bytes_done / elapsed / (1024 * 1024)\\n            pct = (bytes_done / total_bytes * 100) if total_bytes > 0 else 0\\n            \\n            root.after(0, lambda: self.progress_var.set(min(max(pct, 0), 100)))\\n            root.after(0, lambda: self.status_var.set(\\n                f\\\"{label_text} | {bytes_to_human(bytes_done)} / {bytes_to_human(total_bytes)} | 速度 {speed_mb:.2f} MB/s\\\"\\n            ))\\n        \\n        # 1. 复制照片\\n        for src, base, ext in plan:\\n            if self.stop_event.is_set():\\n                return\\n            \\n            if src in done:\\n                update_status(\\\"照片\\\")\\n                continue\\n            \\n            td = raw_dir if is_raw_ext(ext) else jpg_dir\\n            dst_path = unique_path(td, f\\\"{base}.{ext}\\\")\\n            \\n            try:\\n                size = 0\\n                try: size = os.path.getsize(src)\\n                except Exception: size = 0\\n                \\n                shutil.copy2(src, dst_path)\\n                created.append(dst_path)\\n                final_map[src] = dst_path\\n                \\n                with open(log_file, \\\"a\\\", encoding=\\\"utf-8\\\") as f:\\n                    f.write(f\\\"完成: {src} -> {os.path.basename(dst_path)}\\\\n\\\")\\n                \\n                bytes_done += size\\n                update_status(\\\"照片\\\")\\n                \\n                # 更新日志和预览（降低频率）\\n                current_time = time.time()\\n                if current_time - last_preview_update > 1:  # 每秒最多更新一次预览\\n                    root.after(0, lambda dst=dst_path: log_add(self.log_widget, f\\\"复制：{os.path.basename(dst)}\\\"))\\n                    \\n                    if self.preview_manager and is_jpg_ext(ext):  # 只预览JPG以提高性能\\n                        file_info = f\\\"{bytes_to_human(size)} | {os.path.basename(dst)}\\\"\\n                        root.after(0, lambda src=src, info=file_info: self.preview_manager.show_preview(src, info))\\n                    \\n                    last_preview_update = current_time\\n                    \\n            except Exception as e:\\n                with open(log_file, \\\"a\\\", encoding=\\\"utf-8\\\") as f:\\n                    f.write(f\\\"错误: {src} | {e}\\\\n\\\")\\n        \\n        # 2. 复制视频\\n        for src in video_files:\\n            if self.stop_event.is_set():\\n                return\\n            \\n            if src in done:\\n                update_status(\\\"视频\\\")\\n                continue\\n            \\n            dst_path = unique_path(vid_dir, os.path.basename(src))\\n            \\n            try:\\n                size = 0\\n                try: size = os.path.getsize(src)\\n                except Exception: size = 0\\n                \\n                shutil.copy2(src, dst_path)\\n                created.append(dst_path)\\n                \\n                with open(log_file, \\\"a\\\", encoding=\\\"utf-8\\\") as f:\\n                    f.write(f\\\"完成: {src} -> {os.path.basename(dst_path)}\\\\n\\\")\\n                \\n                bytes_done += size\\n                update_status(\\\"视频\\\")\\n                \\n                # 更新日志（降低频率）\\n                current_time = time.time()\\n                if current_time - last_preview_update > 2:  # 视频更新频率更低\\n                    root.after(0, lambda dst=dst_path: log_add(self.log_widget, f\\\"复制视频：{os.path.basename(dst)}\\\"))\\n                    last_preview_update = current_time\\n                    \\n            except Exception as e:\\n                with open(log_file, \\\"a\\\", encoding=\\\"utf-8\\\") as f:\\n                    f.write(f\\\"错误: {src} | {e}\\\\n\\\")\\n        \\n        # 3. 提取星标照片\\n        if extract_star and not self.stop_event.is_set():\\n            root.after(0, lambda: log_add(self.log_widget, \\\"开始提取星标照片…\\\"))\\n            star_count = 0\\n            \\n            for src, base, ext in plan:\\n                if self.stop_event.is_set():\\n                    return\\n                \\n                try:\\n                    if is_starred_file(src):\\n                        src_copied_path = final_map.get(src, src)\\n                        if is_jpg_ext(ext):\\n                            dst_star = unique_path(star_jpg, os.path.basename(src_copied_path))\\n                        else:\\n                            dst_star = unique_path(star_raw, os.path.basename(src_copied_path))\\n                        \\n                        shutil.copy2(src_copied_path, dst_star)\\n                        created.append(dst_star)\\n                        star_count += 1\\n                        \\n                        # 偶尔更新日志\\n                        if star_count % 5 == 0:\\n                            root.after(0, lambda cnt=star_count: log_add(self.log_widget, f\\\"已提取 {cnt} 个星标照片\\\"))\\n                            \\n                except Exception as e:\\n                    with open(log_file, \\\"a\\\", encoding=\\\"utf-8\\\") as f:\\n                        f.write(f\\\"星标复制错误: {src} | {e}\\\\n\\\")\\n            \\n            root.after(0, lambda cnt=star_count: log_add(self.log_widget, f\\\"星标提取完成，共 {cnt} 个文件\\\"))\\n        \\n        # 更新进度到100%\\n        root.after(0, lambda: self.progress_var.set(100))\\n        root.after(0, lambda: self.status_var.set(\\\"完成\\\"))\\n        \\n        # 保存创建的文件列表\\n        self.created_files = created\\n    \\n    def _show_finish_window(self, root, target_dir):\\n        \\\"\\\"\\\"显示完成窗口\\\"\\\"\\\"\\n        win = tk.Toplevel(root)\\n        win.title(\\\"完成\\\")\\n        win.resizable(False, False)\\n        win.transient(root)      # 置于父窗口上方\\n        win.grab_set()           # 获取焦点\\n        \\n        # 加载配置并应用主题\\n        try:\\n            theme_key = load_config().get(\\\"theme\\\", \\\"light\\\")\\n            ThemeManager.apply_theme(win, theme_key)\\n        except Exception:\\n            pass\\n        \\n        # 窗口样式\\n        P = ThemeManager.THEMES[\\\"dark\\\" if theme_key == \\\"dark\\\" else \\\"light\\\"]\\n        win.configure(bg=P[\\\"BG\\\"])\\n        \\n        # 添加卡片效果（通过Frame实现）\\n        card = ttk.Frame(win, style=\\\"Modern.Card.TFrame\\\", padding=24)\\n        card.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)\\n        \\n        # 标题\\n        ttk.Label(card, text=\\\"导入完成\\\", style=\\\"Modern.Title.TLabel\\\").pack(anchor=\\\"w\\\", pady=(0, 16))\\n        \\n        # 信息\\n        info_frame = ttk.Frame(card, style=\\\"Modern.Frame.TFrame\\\")\\n        info_frame.pack(fill=tk.X, pady=(0, 24))\\n        \\n        ttk.Label(info_frame, text=\\\"输出目录：\\\", style=\\\"Modern.Body.TLabel\\\").grid(row=0, column=0, sticky=\\\"w\\\", pady=(0, 4))\\n        ttk.Label(info_frame, text=target_dir, style=\\\"Modern.Secondary.TLabel\\\").grid(row=0, column=1, sticky=\\\"w\\\", pady=(0, 4))\\n        \\n        # 按钮区域\\n        btn_frame = ttk.Frame(card, style=\\\"Modern.Frame.TFrame\\\")\\n        btn_frame.pack(fill=tk.X, anchor=\\\"e\\\")\\n        \\n        def open_folder():\\n            _open_folder(target_dir)\\n            win.destroy()\\n        \\n        def undo():\\n            removed = 0\\n            for p in self.created_files:\\n                try:\\n                    if os.path.isfile(p):\\n                        os.remove(p); removed += 1\\n                except Exception:\\n                    pass\\n            \\n            # 清理空目录\\n            for sub in [\\\"RAW\\\", \\\"JPG\\\", \\\"VIDEO\\\", \\\"已星标照片\\\", \\\"已星标照片\\\\\\\\已星标JPG\\\", \\\"已星标照片\\\\\\\\已星标RAW\\\"]:\\n                d = os.path.join(target_dir, sub)\\n                try:\\n                    if os.path.isdir(d) and not os.listdir(d):\\n                        os.rmdir(d)\\n                except Exception:\\n                    pass\\n            \\n            try:\\n                if os.path.isdir(target_dir) and not os.listdir(target_dir):\\n                    os.rmdir(target_dir)\\n            except Exception:\\n                pass\\n            \\n            messagebox.showinfo(\\\"撤销完成\\\", f\\\"已删除本次导入生成的 {removed} 个文件。\\\")\\n            win.destroy()\\n        \\n        # 创建按钮\\n        ttk.Button(btn_frame, text=\\\"关闭\\\", style=\\\"Modern.Secondary.TButton\\\", command=win.destroy).pack(side=tk.RIGHT, padx=(0, 8))\\n        ttk.Button(btn_frame, text=\\\"撤销本次导入\\\", style=\\\"Modern.Secondary.TButton\\\", command=undo).pack(side=tk.RIGHT, padx=(0, 8))\\n        ttk.Button(btn_frame, text=\\\"打开输出文件夹\\\", style=\\\"Modern.Primary.TButton\\\", command=open_folder).pack(side=tk.RIGHT)\\n        \\n        # 计算尺寸后居中到父窗口\\n        win.update_idletasks()\\n        self._center_on_parent(win, root)\\n    \\n    def _center_on_parent(self, child: tk.Toplevel, parent: tk.Tk):\\n        \\\"\\\"\\\"把子窗口居中到父窗口\\\"\\\"\\\"\\n        parent.update_idletasks()\\n        child.update_idletasks()\\n        \\n        pw, ph = parent.winfo_width(), parent.winfo_height()\\n        px, py = parent.winfo_rootx(), parent.winfo_rooty()\\n        cw, ch = child.winfo_width(), child.winfo_height()\\n        \\n        x = px + max((pw - cw) // 2, 0)\\n        y = py + max((ph - ch) // 2, 0)\\n        \\n        child.geometry(f\\\"+{x}+{y}\\\")\\n\\n# ---------- 主应用类 ----------\\nclass ModernPhotoSorterApp:\\n    \\\"\\\"\\\"现代UI版本的影像管理助手应用程序\\\"\\\"\\\"\\n    \\n    def __init__(self):\\n        # 加载配置\\n        self.cfg = load_config()\\n        self.theme_key = self.cfg.get(\\\"theme\\\", \\\"light\\\")\\n        self.sash_ratio = float(self.cfg.get(\\\"sash_ratio\\\", 0.55))\\n        \\n        # 创建主窗口\\n        self.root = tk.Tk()\\n        self.root.title(f\\\"陈同学影像管理助手  {VERSION}\\\")\\n        \\n        # 恢复窗口位置和大小\\n        pos = self.cfg.get(\\\"window_pos\\\", {\\\"x\\\": 100, \\\"y\\\": 100})\\n        size = self.cfg.get(\\\"window_size\\\", {\\\"width\\\": 1000, \\\"height\\\": 720})\\n        self.root.geometry(f\\\"{size['width']}x{size['height']}+{pos['x']}+{pos['y']}\\\")\\n        self.root.minsize(900, 650)\\n        \\n        # 应用主题\\n        self.theme_manager = ThemeManager\\n        self.theme_manager.apply_theme(self.root, self.theme_key)\\n        \\n        # 创建UI组件\\n        self._create_ui()\\n        \\n        # 初始化数据\\n        self._initialize_data()\\n        \\n        # 绑定事件\\n        self._bind_events()\\n    \\n    def _create_ui(self):\\n        \\\"\\\"\\\"创建用户界面\\\"\\\"\\\"\\n        # 顶部栏\\n        header = ttk.Frame(self.root, style=\\\"Modern.Frame.TFrame\\\")\\n        header.pack(fill=tk.X, padx=24, pady=(16, 0))\\n        \\n        # 标题和主题选择\\n        title_frame = ttk.Frame(header, style=\\\"Modern.Frame.TFrame\\\")\\n        title_frame.pack(fill=tk.X)\\n        \\n        ttk.Label(title_frame, text=\\\"照片/视频导入与分类\\\", style=\\\"Modern.Title.TLabel\\\").pack(side=tk.LEFT)\\n        \\n        theme_frame = ttk.Frame(title_frame, style=\\\"Modern.Frame.TFrame\\\")\\n        theme_frame.pack(side=tk.RIGHT, pady=8)\\n        \\n        ttk.Label(theme_frame, text=\\\"主题:\\\", style=\\\"Modern.Body.TLabel\\\").pack(side=tk.LEFT, padx=(0, 8))\\n        \\n        self.theme_box = ttk.Combobox(\\n            theme_frame, \\n            state=\\\"readonly\\\", \\n            values=THEMES, \\n            width=8,\\n            style=\\\"Modern.TCombobox\\\"\\n        )\\n        self.theme_box.pack(side=tk.LEFT)\\n        self.theme_box.set(\\\"日间\\\" if self.theme_key == \\\"light\\\" else \\\"暗黑\\\")\\n        \\n        # 主内容区域 - 使用PanedWindow实现可拖动分割\\n        self.paned = ttk.Panedwindow(self.root, orient=\\\"vertical\\\")\\n        self.paned.pack(fill=tk.BOTH, expand=True, padx=24, pady=(16, 8))\\n        \\n        # 上部：设置区域\\n        self.top_frame = ttk.Frame(self.paned, style=\\\"Modern.Frame.TFrame\\\")\\n        self.paned.add(self.top_frame, weight=3)\\n        \\n        # 下部：日志和预览区域\\n        self.bottom_frame = ttk.Frame(self.paned, style=\\\"Modern.Frame.TFrame\\\")\\n        self.paned.add(self.bottom_frame, weight=5)\\n        \\n        # ----- 上部设置区域 ----- #\\n        # 导入设置卡片\\n        import_card = ttk.Frame(self.top_frame, style=\\\"Modern.Card.TFrame\\\", padding=20)\\n        import_card.pack(fill=tk.X, pady=(0, 12))\\n        \\n        ttk.Label(import_card, text=\\\"导入设置\\\", style=\\\"Modern.Subtitle.TLabel\\\").pack(anchor=\\\"w\\\", pady=(0, 16))\\n        \\n        # 表单布局\\n        form_frame = ttk.Frame(import_card, style=\\\"Modern.Frame.TFrame\\\")\\n        form_frame.pack(fill=tk.X)\\n        \\n        # 素材盘选择\\n        self._create_form_row(form_frame, \\\"选择素材盘\\\", 0)\\n        \\n        self.combo_src = ttk.Combobox(\\n            form_frame,\\n            state=\\\"readonly\\\",\\n            width=60,\\n            style=\\\"Modern.TCombobox\\\"\\n        )\\n        self.combo_src.grid(row=0, column=1, sticky=\\\"ew\\\", padx=(8, 12))\\n        \\n        self.btn_refresh_src = ttk.Button(\\n            form_frame,\\n            text=\\\"刷新\\\",\\n            style=\\\"Modern.Secondary.TButton\\\",\\n            command=lambda: self.refresh_sources(auto_pick=True)\\n        )\\n        self.btn_refresh_src.grid(row=0, column=2, padx=(0, 8))\\n        \\n        # 目标盘选择\\n        self._create_form_row(form_frame, \\\"拷入到\\\", 1)\\n        \\n        self.combo_dst = ttk.Combobox(\\n            form_frame,\\n            state=\\\"readonly\\\",\\n            width=60,\\n            style=\\\"Modern.TCombobox\\\"\\n        )\\n        self.combo_dst.grid(row=1, column=1, sticky=\\\"ew\\\", padx=(8, 12), pady=(12, 0))\\n        \\n        self.btn_refresh_dst = ttk.Button(\\n            form_frame,\\n            text=\\\"刷新\\\",\\n            style=\\\"Modern.Secondary.TButton\\\",\\n            command=self.refresh_dests\\n        )\\n        self.btn_refresh_dst.grid(row=1, column=2, padx=(0, 8), pady=(12, 0))\\n        \\n        # 拍摄类型和星标选项\\n        self._create_form_row(form_frame, \\\"拍摄类型\\\", 2)\\n        \\n        self.combo_cat = ttk.Combobox(\\n            form_frame,\\n            state=\\\"readonly\\\",\\n            values=CATEGORIES,\\n            width=20,\\n            style=\\\"Modern.TCombobox\\\"\\n        )\\n        self.combo_cat.grid(row=2, column=1, sticky=\\\"w\\\", padx=(8, 12), pady=(12, 0))\\n        self.combo_cat.current(0)\\n        \\n        self.star_var = tk.BooleanVar(value=False)\\n        self.chk_star = ttk.Checkbutton(\\n            form_frame,\\n            text=\\\"提取星标照片\\\",\\n            variable=self.star_var,\\n            style=\\\"Modern.TCheckbutton\\\"\\n        )\\n        self.chk_star.grid(row=2, column=2, sticky=\\\"w\\\", padx=(0, 8), pady=(12, 0))\\n        \\n        # 配置列权重\\n        form_frame.columnconfigure(1, weight=1)\\n        \\n        # 操作区域卡片\\n        action_card = ttk.Frame(self.top_frame, style=\\\"Modern.Card.TFrame\\\", padding=20)\\n        action_card.pack(fill=tk.X)\\n        \\n        # 进度条\\n        self.progress_var = tk.DoubleVar(value=0)\\n        self.progress_bar = ttk.Progressbar(\\n            action_card,\\n            variable=self.progress_var,\\n            style=\\\"Modern.Horizontal.TProgressbar\\\",\\n            orient=\\\"horizontal\\\",\\n            length=0,  # 由fill=tk.X自动填充\\n            mode=\\\"determinate\\\"\\n        )\\n        self.progress_bar.pack(fill=tk.X, pady=(0, 8))\\n        \\n        # 状态标签\\n        self.status_var = tk.StringVar(value=\\\"待机\\\")\\n        self.status_label = ttk.Label(\\n            action_card,\\n            textvariable=self.status_var,\\n            style=\\\"Modern.Secondary.TLabel\\\"\\n        )\\n        self.status_label.pack(anchor=\\\"w\\\", pady=(0, 16))\\n        \\n        # 按钮区域\\n        btn_frame = ttk.Frame(action_card, style=\\\"Modern.Frame.TFrame\\\")\\n        btn_frame.pack(fill=tk.X, anchor=\\\"e\\\")\\n        \\n        self.btn_exit = ttk.Button(\\n            btn_frame,\\n            text=\\\"退出\\\",\\n            style=\\\"Modern.Secondary.TButton\\\",\\n            command=self.root.destroy\\n        )\\n        self.btn_exit.pack(side=tk.RIGHT, padx=(0, 8))\\n        \\n        self.btn_stop = ttk.Button(\\n            btn_frame,\\n            text=\\\"停止\\\",\\n            style=\\\"Modern.Secondary.TButton\\\",\\n            command=self.stop_action,\\n            state=tk.DISABLED\\n        )\\n        self.btn_stop.pack(side=tk.RIGHT, padx=(0, 8))\\n        \\n        self.btn_start = ttk.Button(\\n            btn_frame,\\n            text=\\\"开始分类\\\",\\n            style=\\\"Modern.Primary.TButton\\\",\\n            command=self.start_action\\n        )\\n        self.btn_start.pack(side=tk.RIGHT)\\n        \\n        # ----- 下部日志和预览区域 ----- #\\n        # 创建水平分割的面板\\n        self.bottom_paned = ttk.Panedwindow(self.bottom_frame, orient=\\\"horizontal\\\")\\n        self.bottom_paned.pack(fill=tk.BOTH, expand=True)\\n        \\n        # 左侧：预览区域\\n        preview_frame = ttk.Frame(self.bottom_paned, style=\\\"Modern.Frame.TFrame\\\")\\n        self.bottom_paned.add(preview_frame, weight=1)\\n        \\n        # 预览卡片\\n        preview_card = ttk.Frame(preview_frame, style=\\\"Modern.Card.TFrame\\\", padding=16)\\n        preview_card.pack(fill=tk.BOTH, expand=True, pady=(0, 12))\\n        \\n        ttk.Label(preview_card, text=\\\"图像预览\\\", style=\\\"Modern.Subtitle.TLabel\\\").pack(anchor=\\\"w\\\", pady=(0, 12))\\n        \\n        # 预览画布\\n        self.preview_canvas = tk.Canvas(\\n            preview_card,\\n            relief=\\\"flat\\\",\\n            highlightthickness=0\\n        )\\n        self.preview_canvas.pack(fill=tk.BOTH, expand=True)\\n        \\n        # 右侧：日志区域\\n        log_frame = ttk.Frame(self.bottom_paned, style=\\\"Modern.Frame.TFrame\\\")\\n        self.bottom_paned.add(log_frame, weight=1)\\n        \\n        # 日志卡片\\n        log_card = ttk.Frame(log_frame, style=\\\"Modern.Card.TFrame\\\", padding=16)\\n        log_card.pack(fill=tk.BOTH, expand=True, pady=(0, 12))\\n        \\n        ttk.Label(log_card, text=\\\"信息日志\\\", style=\\\"Modern.Subtitle.TLabel\\\").pack(anchor=\\\"w\\\", pady=(0, 12))\\n        \\n        # 日志文本框\\n        self.info_box = tk.Text(\\n            log_card,\\n            wrap=\\\"word\\\",\\n            bd=0,\\n            relief=\\\"flat\\\",\\n            state=\\\"disabled\\\",\\n            highlightthickness=0\\n        )\\n        self.info_box.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)\\n        \\n        # 滚动条\\n        self.log_scrollbar = ttk.Scrollbar(\\n            log_card,\\n            command=self.info_box.yview\\n        )\\n        self.log_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\\n        \\n        self.info_box.configure(yscrollcommand=self.log_scrollbar.set)\\n        \\n        # 底部版权信息\\n        footer = ttk.Label(\\n            self.root,\\n            text=\\\"此软件完全免费，请勿倒卖！ by: 抖音@摄影师陈同学\\\",\\n            style=\\\"Modern.Secondary.TLabel\\\",\\n            anchor=\\\"center\\\"\\n        )\\n        footer.pack(fill=tk.X, pady=(0, 12))\\n    \\n    def _create_form_row(self, parent, label_text, row):\\n        \\\"\\\"\\\"创建表单行\\\"\\\"\\\"\\n        ttk.Label(\\n            parent,\\n            text=label_text,\\n            style=\\\"Modern.Body.TLabel\\\"\\n        ).grid(row=row, column=0, sticky=\\\"e\\\", pady=(row > 0 and 12 or 0, 0))\\n    \\n    def _initialize_data(self):\\n        \\\"\\\"\\\"初始化数据\\\"\\\"\\\"\\n        # 创建图像预览管理器\\n        self.preview_manager = ImagePreviewManager(self.preview_canvas, self.theme_manager)\\n        self.preview_manager.clear_preview()\\n        \\n        # 创建复制管理器\\n        self.copy_manager = CopyManager(\\n            self.info_box,\\n            self.status_var,\\n            self.progress_var,\\n            self.preview_manager\\n        )\\n        \\n        # 初始化驱动器列表\\n        self.refresh_sources(auto_pick=True)\\n    \\n    def _bind_events(self):\\n        \\\"\\\"\\\"绑定事件处理程序\\\"\\\"\\\"\\n        # 主题切换\\n        self.theme_box.bind(\\\"<<ComboboxSelected>>\\\", self.on_theme_change)\\n        \\n        # 窗口关闭事件\\n        self.root.protocol(\\\"WM_DELETE_WINDOW\\\", self.on_window_close)\\n        \\n        # 分割窗拖动事件\\n        self.paned.bind(\\\"<ButtonRelease-1>\\\", self.remember_sash)\\n        self.root.bind(\\\"<Configure>\\\", lambda e: self.root.after(50, self.remember_sash))\\n        \\n        # 应用分割比例\\n        self.root.after(300, self.apply_sash_ratio_later)\\n        \\n        # 版权提示\\n        self.root.after(500, self.show_copyright)\\n    \\n    def refresh_sources(self, auto_pick=False):\\n        \\\"\\\"\\\"刷新源驱动器列表\\\"\\\"\\\"\\n        all_drives = list_drives()\\n        removable = []; src_vals = []\\n        \\n        for d in all_drives:\\n            tname = drive_type_name(get_drive_type_code(d))\\n            if get_drive_type_code(d) == 2: removable.append(d)\\n            tag = \\\"(系统)\\\" if is_system_drive(d) else \\\"\\\"\\n            src_vals.append(f\\\"{d}  |  名称: {get_drive_label(d)}  |  类型: {tname}{tag}\\\")\\n        \\n        self.combo_src[\\\"values\\\"] = src_vals\\n        \\n        if auto_pick and removable:\\n            pick = removable[0]\\n            for i, s in enumerate(src_vals):\\n                if s.startswith(pick): \\n                    self.combo_src.current(i)\\n                    break\\n        \\n        log_init_if_empty(self.info_box, \\\"日志已启动\\\")\\n        \\n        if removable:\\n            log_add(self.info_box, f\\\"发现移动盘：{', '.join(removable)}\\\")\\n        else:\\n            log_add(self.info_box, \\\"未检测到移动盘\\\")\\n    \\n    def refresh_dests(self):\\n        \\\"\\\"\\\"刷新目标驱动器列表\\\"\\\"\\\"\\n        vals = []\\n        for p in psutil.disk_partitions(all=False):\\n            letter = p.device.rstrip(\\\"\\\\\\\\\\\")\\n            if get_drive_type_code(letter) != 3: continue\\n            \\n            total, free = get_drive_usage_bytes(letter + \\\"\\\\\\\\\\\")\\n            label = get_drive_label(letter)\\n            vals.append(f\\\"{letter} {label}（{bytes_to_human(free)} / {bytes_to_human(total)}）\\\")\\n        \\n        self.combo_dst[\\\"values\\\"] = vals\\n        log_add(self.info_box, \\\"已刷新目标固定磁盘列表\\\")\\n    \\n    def start_action(self):\\n        \\\"\\\"\\\"开始分类操作\\\"\\\"\\\"\\n        # 检查源设备\\n        sv = self.combo_src.get()\\n        if not sv:\\n            messagebox.showwarning(\\\"提示\\\", \\\"请先选择素材盘。\\\")\\n            return\\n        \\n        src_drive = sv.split(\\\"|\\\", 1)[0].strip()\\n        \\n        # 检查源设备类型\\n        dtype = drive_type_name(get_drive_type_code(src_drive))\\n        \\n        # 系统盘警告\\n        if is_system_drive(src_drive):\\n            if not messagebox.askyesno(\\\"高风险确认\\\", f\\\"{src_drive} 是系统盘，不建议作为素材盘源。继续？\\\"):\\n                return\\n            if not messagebox.askyesno(\\\"二次确认\\\", \\\"再次确认从系统盘作为相机源复制？\\\"):\\n                return\\n        elif get_drive_type_code(src_drive) != 2:\\n            if not messagebox.askyesno(\\\"固定磁盘警告\\\", f\\\"{src_drive} 为固定盘，通常应选移动盘。继续？\\\"):\\n                return\\n        \\n        # 获取目标驱动器\\n        dst_letter = \\\"\\\"\\n        if self.combo_dst.get():\\n            dst_letter = self.combo_dst.get().split(\\\" \\\", 1)[0].strip().rstrip(\\\"\\\\\\\\\\\")\\n        \\n        # 更新按钮状态\\n        self.btn_start.config(state=tk.DISABLED)\\n        self.btn_stop.config(state=tk.NORMAL)\\n        \\n        # 启动复制线程\\n        copy_thread = self.copy_manager.start_copy(\\n            src_drive,\\n            dst_letter,\\n            self.cfg,\\n            self.root,\\n            self.combo_cat.get().strip(),\\n            extract_star=self.star_var.get()\\n        )\\n        \\n        # 监控线程完成\\n        def check_thread():\\n            if copy_thread.is_alive():\\n                self.root.after(500, check_thread)\\n            else:\\n                # 恢复按钮状态\\n                self.btn_start.config(state=tk.NORMAL)\\n                self.btn_stop.config(state=tk.DISABLED)\\n        \\n        self.root.after(500, check_thread)\\n    \\n    def stop_action(self):\\n        \\\"\\\"\\\"停止操作\\\"\\\"\\\"\\n        self.copy_manager.stop_copy()\\n        self.status_var.set(\\\"正在停止...\\\")\\n    \\n    def on_theme_change(self, event=None):\\n        \\\"\\\"\\\"主题切换处理\\\"\\\"\\\"\\n        sel = self.theme_box.get()\\n        key = \\\"light\\\" if sel == \\\"日间\\\" else \\\"dark\\\"\\n        \\n        self.cfg[\\\"theme\\\"] = key\\n        save_config(self.cfg)\\n        \\n        # 应用新主题\\n        self.theme_manager.apply_theme(\\n            self.root,\\n            key,\\n            widgets={\\n                \\\"text\\\": [self.info_box],\\n                \\\"canvas\\\": [self.preview_canvas]\\n            }\\n        )\\n    \\n    def remember_sash(self, event=None):\\n        \\\"\\\"\\\"记住分割窗口位置\\\"\\\"\\\"\\n        try:\\n            self.root.update_idletasks()\\n            total_h = self.paned.winfo_height()\\n            pos = self.paned.sashpos(0)\\n            ratio = round(pos / max(total_h, 1), 4)\\n            \\n            self.cfg[\\\"sash_ratio\\\"] = max(0.15, min(0.85, ratio))\\n            save_config(self.cfg)\\n        except Exception:\\n            pass\\n    \\n    def apply_sash_ratio_later(self):\\n        \\\"\\\"\\\"延迟应用分割比例\\\"\\\"\\\"\\n        try:\\n            self.root.update_idletasks()\\n            total_h = self.paned.winfo_height()\\n            \\n            if total_h <= 0:\\n                self.root.after(100, self.apply_sash_ratio_later)\\n                return\\n            \\n            pos = int(total_h * self.sash_ratio)\\n            self.paned.sashpos(0, pos)\\n        except Exception:\\n            pass\\n    \\n    def show_copyright(self):\\n        \\\"\\\"\\\"显示版权信息\\\"\\\"\\\"\\n        log_add(self.info_box, \\\"=== 陈同学影像管理助手 v2.0.0 ===\\\")\\n        log_add(self.info_box, \\\"完全免费，禁止商用或倒卖！\\\")\\n        log_add(self.info_box, \\\"作者：抖音@摄影师陈同学\\\")\\n    \\n    def on_window_close(self):\\n        \\\"\\\"\\\"窗口关闭事件处理\\\"\\\"\\\"\\n        # 保存窗口位置和大小\\n        pos = {\\n            \\\"x\\\": self.root.winfo_x(),\\n            \\\"y\\\": self.root.winfo_y()\\n        }\\n        \\n        size = {\\n            \\\"width\\\": self.root.winfo_width(),\\n            \\\"height\\\": self.root.winfo_height()\\n        }\\n        \\n        self.cfg[\\\"window_pos\\\"] = pos\\n        self.cfg[\\\"window_size\\\"] = size\\n        save_config(self.cfg)\\n        \\n        # 检查是否正在复制\\n        if hasattr(self, \\\"copy_manager\\\") and self.copy_manager.stop_event.is_set():\\n            if messagebox.askyesnocancel(\\\"确认退出\\\", \\\"正在进行复制操作，确定要退出吗？\\\"):\\n                self.copy_manager.stop_copy()\\n                self.root.destroy()\\n        else:\\n            self.root.destroy()\\n    \\n    def run(self):\\n        \\\"\\\"\\\"运行应用\\\"\\\"\\\"\\n        self.root.mainloop()\\n\\n# ---------- 应用入口 ----------\\nif __name__ == \\\"__main__\\\":\\n    # 设置中文字体支持\\n    if platform.system() == \\\"Windows\\\":\\n        os.environ[\\\"TCL_LIBRARY\\\"] = r\\\"C:\\\\Program Files\\\\Python38\\\\tcl\\\\tcl8.6\\\"\\n        os.environ[\\\"TK_LIBRARY\\\"] = r\\\"C:\\\\Program Files\\\\Python38\\\\tcl\\\\tk8.6\\\"\\n    \\n    # 创建并运行应用\\n    app = ModernPhotoSorterApp()\\n    app.run()\",\"originTextLength\":52471,\"aiScene\":\"builder\",\"behaviorType\":\"accept\",\"updateTime\":1761281556214},{\"originRange\":{\"start\":{\"line\":594,\"character\":0},\"end\":{\"line\":599,\"character\":48}},\"modifyRange\":{\"start\":{\"line\":594,\"character\":0},\"end\":{\"line\":599,\"character\":48}},\"action\":\"None\",\"isLine\":false,\"originText\":\"                    f\\\\\\\"RAW：{counts[\\\\'RAW\\\\']}（{bytes_to_human(sizes[\\\\'RAW\\\\'])}）\\\\\\\\n\\\\\\\"\\\\n                    f\\\\\\\"JPG：{counts[\\\\'JPG\\\\']}（{bytes_to_human(sizes[\\\\'JPG\\\\'])}）\\\\\\\\n\\\\\\\"\\\\n                    f\\\\\\\"VIDEO：{counts[\\\\'VIDEO\\\\']}（{bytes_to_human(sizes[\\\\'VIDEO\\\\'])}）\\\\\\\\n\\\\\\\"\\\\n                    f\\\\\\\"合计：{total_files}（{bytes_to_human(total_size)}）\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n                    f\\\\\\\"将复制到：年/拍摄类型/MM月/MM.DD_拍摄名/（RAW,JPG,VIDEO，及可选已星标照片）\\\\\\\\n\\\\\\\"\\\\n                    f\\\\\\\"照片重命名：MMDD-0001 起；视频保留原名。\\\\\\\"\",\"originAcceptText\":\"                    f\\\"RAW：{counts['RAW']}（{bytes_to_human(sizes['RAW'])}）\\\\n\\\"\\n                    f\\\"JPG：{counts['JPG']}（{bytes_to_human(sizes['JPG'])}）\\\\n\\\"\\n                    f\\\"VIDEO：{counts['VIDEO']}（{bytes_to_human(sizes['VIDEO'])}）\\\\n\\\"\\n                    f\\\"合计：{total_files}（{bytes_to_human(total_size)}）\\\\n\\\\n\\\"\\n                    f\\\"将复制到：年/拍摄类型/MM月/MM.DD_拍摄名/（RAW,JPG,VIDEO，及可选已星标照片）\\\\n\\\"\\n                    f\\\"照片重命名：MMDD-0001 起；视频保留原名。\\\"\",\"originTextLength\":435,\"aiScene\":\"builder\",\"behaviorType\":\"accept\",\"updateTime\":1761281648314},{\"originRange\":{\"start\":{\"line\":1479,\"character\":0},\"end\":{\"line\":1479,\"character\":0}},\"modifyRange\":{\"start\":{\"line\":1479,\"character\":0},\"end\":{\"line\":1479,\"character\":0}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\",\"originAcceptText\":\"\",\"originTextLength\":0,\"aiScene\":\"builder\",\"behaviorType\":\"accept\",\"updateTime\":1761281648326}]"
}